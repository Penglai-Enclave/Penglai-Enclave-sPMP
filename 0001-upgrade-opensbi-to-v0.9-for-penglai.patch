From bc860578d6612bf6728ef2a978d7f527e17ed2aa Mon Sep 17 00:00:00 2001
From: Dong Du <dd_nirvana@sjtu.edu.cn>
Date: Wed, 2 Jun 2021 16:04:56 +0800
Subject: [PATCH] upgrade opensbi to v0.9 for penglai

Signed-off-by: Dong Du <dd_nirvana@sjtu.edu.cn>
---
 opensbi-0.9/Makefile                          |   1 +
 opensbi-0.9/include/sbi/riscv_encoding.h      |  19 +
 opensbi-0.9/include/sbi/sbi_ecall_interface.h |  14 +
 opensbi-0.9/include/sm/atomic.h               |  78 ++
 opensbi-0.9/include/sm/bits.h                 |  35 +
 opensbi-0.9/include/sm/enclave.h              |  97 +++
 opensbi-0.9/include/sm/enclave_args.h         |  31 +
 opensbi-0.9/include/sm/ipi.h                  |  21 +
 opensbi-0.9/include/sm/math.h                 |  78 ++
 .../include/sm/platform/spmp/enclave_mm.h     |  67 ++
 .../include/sm/platform/spmp/ipi_handler.h    |   6 +
 .../include/sm/platform/spmp/platform.h       |  11 +
 .../sm/platform/spmp/platform_thread.h        |  18 +
 opensbi-0.9/include/sm/platform/spmp/spmp.h   |  85 +++
 opensbi-0.9/include/sm/pmp.h                  |  72 ++
 opensbi-0.9/include/sm/print.h                |   9 +
 opensbi-0.9/include/sm/sm.h                   |  75 ++
 opensbi-0.9/include/sm/thread.h               |  86 +++
 opensbi-0.9/include/sm/vm.h                   |  35 +
 opensbi-0.9/lib/sbi/objects.mk                |  14 +
 opensbi-0.9/lib/sbi/sbi_ecall.c               |  24 +
 opensbi-0.9/lib/sbi/sbi_ecall_base.c          |  29 +
 opensbi-0.9/lib/sbi/sbi_init.c                |   2 +
 opensbi-0.9/lib/sbi/sbi_trap.c                |   7 +
 opensbi-0.9/lib/sbi/sm/.gitignore             |   1 +
 opensbi-0.9/lib/sbi/sm/enclave.c              | 713 ++++++++++++++++++
 opensbi-0.9/lib/sbi/sm/ipi.c                  |  54 ++
 opensbi-0.9/lib/sbi/sm/math.c                 |   1 +
 .../lib/sbi/sm/platform/spmp/enclave_mm.c     | 690 +++++++++++++++++
 .../lib/sbi/sm/platform/spmp/ipi_handler.c    |  21 +
 .../lib/sbi/sm/platform/spmp/platform.c       |  42 ++
 .../sbi/sm/platform/spmp/platform_thread.c    |  34 +
 opensbi-0.9/lib/sbi/sm/platform/spmp/spmp.c   | 171 +++++
 opensbi-0.9/lib/sbi/sm/pmp.c                  | 191 +++++
 opensbi-0.9/lib/sbi/sm/sm.ac                  |   3 +
 opensbi-0.9/lib/sbi/sm/sm.c                   | 182 +++++
 opensbi-0.9/lib/sbi/sm/sm.mk.in               |  25 +
 opensbi-0.9/lib/sbi/sm/thread.c               |  62 ++
 38 files changed, 3104 insertions(+)
 create mode 100644 opensbi-0.9/include/sm/atomic.h
 create mode 100644 opensbi-0.9/include/sm/bits.h
 create mode 100644 opensbi-0.9/include/sm/enclave.h
 create mode 100644 opensbi-0.9/include/sm/enclave_args.h
 create mode 100644 opensbi-0.9/include/sm/ipi.h
 create mode 100644 opensbi-0.9/include/sm/math.h
 create mode 100644 opensbi-0.9/include/sm/platform/spmp/enclave_mm.h
 create mode 100644 opensbi-0.9/include/sm/platform/spmp/ipi_handler.h
 create mode 100644 opensbi-0.9/include/sm/platform/spmp/platform.h
 create mode 100644 opensbi-0.9/include/sm/platform/spmp/platform_thread.h
 create mode 100644 opensbi-0.9/include/sm/platform/spmp/spmp.h
 create mode 100644 opensbi-0.9/include/sm/pmp.h
 create mode 100644 opensbi-0.9/include/sm/print.h
 create mode 100644 opensbi-0.9/include/sm/sm.h
 create mode 100644 opensbi-0.9/include/sm/thread.h
 create mode 100644 opensbi-0.9/include/sm/vm.h
 create mode 100644 opensbi-0.9/lib/sbi/sm/.gitignore
 create mode 100644 opensbi-0.9/lib/sbi/sm/enclave.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/ipi.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/math.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/platform/spmp/enclave_mm.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/platform/spmp/ipi_handler.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/platform/spmp/platform.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/platform/spmp/platform_thread.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/platform/spmp/spmp.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/pmp.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/sm.ac
 create mode 100644 opensbi-0.9/lib/sbi/sm/sm.c
 create mode 100644 opensbi-0.9/lib/sbi/sm/sm.mk.in
 create mode 100644 opensbi-0.9/lib/sbi/sm/thread.c

diff --git a/opensbi-0.9/Makefile b/opensbi-0.9/Makefile
index d6f097d30..faebba25a 100644
--- a/opensbi-0.9/Makefile
+++ b/opensbi-0.9/Makefile
@@ -204,6 +204,7 @@ GENFLAGS	+=	$(platform-genflags-y)
 GENFLAGS	+=	$(firmware-genflags-y)
 
 CFLAGS		=	-g -Wall -Werror -ffreestanding -nostdlib -fno-strict-aliasing -O2
+CFLAGS          +=      -Wno-unused-variable -Wno-unused-value -Wno-format
 CFLAGS		+=	-fno-omit-frame-pointer -fno-optimize-sibling-calls
 CFLAGS		+=	-mno-save-restore -mstrict-align
 CFLAGS		+=	-mabi=$(PLATFORM_RISCV_ABI) -march=$(PLATFORM_RISCV_ISA)
diff --git a/opensbi-0.9/include/sbi/riscv_encoding.h b/opensbi-0.9/include/sbi/riscv_encoding.h
index e1d0b463c..a1cebd7c2 100644
--- a/opensbi-0.9/include/sbi/riscv_encoding.h
+++ b/opensbi-0.9/include/sbi/riscv_encoding.h
@@ -151,6 +151,22 @@
 #define PMP_ADDR_MASK			_UL(0xFFFFFFFF)
 #endif
 
+/* page table entry (PTE) fields */
+#define PTE_V				_UL(0x001) /* Valid */
+#define PTE_R				_UL(0x002) /* Read */
+#define PTE_W				_UL(0x004) /* Write */
+#define PTE_X				_UL(0x008) /* Execute */
+#define PTE_U				_UL(0x010) /* User */
+#define PTE_G				_UL(0x020) /* Global */
+#define PTE_A				_UL(0x040) /* Accessed */
+#define PTE_D				_UL(0x080) /* Dirty */
+#define PTE_SOFT			_UL(0x300) /* Reserved for Software */
+
+#define PTE_PPN_SHIFT			10
+
+#define PTE_TABLE(PTE)			\
+	(((PTE) & (PTE_V | PTE_R | PTE_W | PTE_X)) == PTE_V)
+
 #if __riscv_xlen == 64
 #define MSTATUS_SD			MSTATUS64_SD
 #define SSTATUS_SD			SSTATUS64_SD
@@ -171,6 +187,9 @@
 #define HGATP_MODE_SHIFT		HGATP32_MODE_SHIFT
 #endif
 
+#define RISCV_PGSHIFT			12
+#define RISCV_PGSIZE			(1 << RISCV_PGSHIFT)
+
 /* ===== User-level CSRs ===== */
 
 /* User Trap Setup (N-extension) */
diff --git a/opensbi-0.9/include/sbi/sbi_ecall_interface.h b/opensbi-0.9/include/sbi/sbi_ecall_interface.h
index 002c6f9cb..16c31920f 100644
--- a/opensbi-0.9/include/sbi/sbi_ecall_interface.h
+++ b/opensbi-0.9/include/sbi/sbi_ecall_interface.h
@@ -38,6 +38,20 @@
 #define SBI_EXT_BASE_GET_MARCHID		0x5
 #define SBI_EXT_BASE_GET_MIMPID			0x6
 
+// SBI CALL NUMBERS for Penglai Enclave
+#define SBI_MM_INIT            100
+#define SBI_CREATE_ENCLAVE      99
+#define SBI_ATTEST_ENCLAVE      98
+#define SBI_RUN_ENCLAVE         97
+#define SBI_STOP_ENCLAVE        96
+#define SBI_RESUME_ENCLAVE      95
+#define SBI_DESTROY_ENCLAVE     94
+#define SBI_ALLOC_ENCLAVE_MM    93
+#define SBI_MEMORY_EXTEND       92
+#define SBI_MEMORY_RECLAIM      91
+#define SBI_ENCLAVE_OCALL       90
+#define SBI_EXIT_ENCLAVE        89
+
 /* SBI function IDs for TIME extension*/
 #define SBI_EXT_TIME_SET_TIMER			0x0
 
diff --git a/opensbi-0.9/include/sm/atomic.h b/opensbi-0.9/include/sm/atomic.h
new file mode 100644
index 000000000..4e085ceab
--- /dev/null
+++ b/opensbi-0.9/include/sm/atomic.h
@@ -0,0 +1,78 @@
+// See LICENSE for license details.
+
+#ifndef _RISCV_ATOMIC_H
+#define _RISCV_ATOMIC_H
+
+//#include "config.h"
+#include <sbi/riscv_encoding.h>
+
+// Currently, interrupts are always disabled in M-mode.
+#define disable_irqsave() (0)
+#define enable_irqrestore(flags) ((void) (flags))
+
+typedef struct { int lock; } spinlock_t;
+#define SPINLOCK_INIT {0}
+
+#define mb() asm volatile ("fence" ::: "memory")
+#define atomic_set(ptr, val) (*(volatile typeof(*(ptr)) *)(ptr) = val)
+#define atomic_read(ptr) (*(volatile typeof(*(ptr)) *)(ptr))
+
+#ifdef __riscv_atomic
+# define atomic_add(ptr, inc) __sync_fetch_and_add(ptr, inc)
+# define atomic_or(ptr, inc) __sync_fetch_and_or(ptr, inc)
+# define atomic_swap(ptr, swp) __sync_lock_test_and_set(ptr, swp)
+# define atomic_cas(ptr, cmp, swp) __sync_val_compare_and_swap(ptr, cmp, swp)
+#else
+# define atomic_binop(ptr, inc, op) ({ \
+  long flags = disable_irqsave(); \
+  typeof(*(ptr)) res = atomic_read(ptr); \
+  atomic_set(ptr, op); \
+  enable_irqrestore(flags); \
+  res; })
+# define atomic_add(ptr, inc) atomic_binop(ptr, inc, res + (inc))
+# define atomic_or(ptr, inc) atomic_binop(ptr, inc, res | (inc))
+# define atomic_swap(ptr, inc) atomic_binop(ptr, inc, (inc))
+# define atomic_cas(ptr, cmp, swp) ({ \
+  long flags = disable_irqsave(); \
+  typeof(*(ptr)) res = *(volatile typeof(*(ptr)) *)(ptr); \
+  if (res == (cmp)) *(volatile typeof(ptr))(ptr) = (swp); \
+  enable_irqrestore(flags); \
+  res; })
+#endif
+
+static inline int spinlock_trylock(spinlock_t* lock)
+{
+  int res = atomic_swap(&lock->lock, -1);
+  mb();
+  return res;
+}
+
+static inline void spinlock_lock(spinlock_t* lock)
+{
+  do
+  {
+    while (atomic_read(&lock->lock))
+      ;
+  } while (spinlock_trylock(lock));
+}
+
+static inline void spinlock_unlock(spinlock_t* lock)
+{
+  mb();
+  atomic_set(&lock->lock,0);
+}
+
+static inline long spinlock_lock_irqsave(spinlock_t* lock)
+{
+  long flags = disable_irqsave();
+  spinlock_lock(lock);
+  return flags;
+}
+
+static inline void spinlock_unlock_irqrestore(spinlock_t* lock, long flags)
+{
+  spinlock_unlock(lock);
+  enable_irqrestore(flags);
+}
+
+#endif
diff --git a/opensbi-0.9/include/sm/bits.h b/opensbi-0.9/include/sm/bits.h
new file mode 100644
index 000000000..8b722287a
--- /dev/null
+++ b/opensbi-0.9/include/sm/bits.h
@@ -0,0 +1,35 @@
+#ifndef _RISCV_BITS_H
+#define _RISCV_BITS_H
+
+#define likely(x) __builtin_expect((x), 1)
+#define unlikely(x) __builtin_expect((x), 0)
+
+//#define ROUNDUP(a, b) ((((a)-1)/(b)+1)*(b))
+//#define ROUNDDOWN(a, b) ((a)/(b)*(b))
+
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+#define CLAMP(a, lo, hi) MIN(MAX(a, lo), hi)
+
+#define EXTRACT_FIELD(val, which) (((val) & (which)) / ((which) & ~((which)-1)))
+#define INSERT_FIELD(val, which, fieldval) (((val) & ~(which)) | ((fieldval) * ((which) & ~((which)-1))))
+
+#define STR(x) XSTR(x)
+#define XSTR(x) #x
+
+#if __riscv_xlen == 64
+# define SLL32    sllw
+# define STORE    sd
+# define LOAD     ld
+# define LWU      lwu
+# define LOG_REGBYTES 3
+#else
+# define SLL32    sll
+# define STORE    sw
+# define LOAD     lw
+# define LWU      lw
+# define LOG_REGBYTES 2
+#endif
+#define REGBYTES (1 << LOG_REGBYTES)
+
+#endif
diff --git a/opensbi-0.9/include/sm/enclave.h b/opensbi-0.9/include/sm/enclave.h
new file mode 100644
index 000000000..1f517e432
--- /dev/null
+++ b/opensbi-0.9/include/sm/enclave.h
@@ -0,0 +1,97 @@
+#ifndef _ENCLAVE_H
+#define _ENCLAVE_H
+
+//#include <string.h>
+#include <sbi/riscv_asm.h>
+#include <sm/bits.h>
+#include <sm/vm.h>
+#include <sbi/riscv_encoding.h>
+#include <sm/enclave_args.h>
+#include <sm/atomic.h>
+//#include "mtrap.h"
+#include <sm/thread.h>
+#include <stdint.h>
+#include <stddef.h>
+
+#define ENCLAVES_PER_METADATA_REGION 256
+#define ENCLAVE_METADATA_REGION_SIZE ((sizeof(struct enclave_t)) * ENCLAVES_PER_METADATA_REGION)
+
+#define ENCLAVE_MODE 1
+
+struct link_mem_t
+{
+  unsigned long mem_size;
+  unsigned long slab_size;
+  unsigned long slab_num;
+  char* addr;
+  struct link_mem_t* next_link_mem;
+};
+
+typedef enum
+{
+  DESTROYED = -1,
+  INVALID = 0,
+  FRESH = 1,
+  RUNNABLE,
+  RUNNING,
+  STOPPED,
+} enclave_state_t;
+
+/*
+ * enclave memory [paddr, paddr + size]
+ * free_mem @ unused memory address in enclave mem
+ */
+struct enclave_t
+{
+  unsigned int eid;
+  enclave_state_t state;
+
+  //memory region of enclave
+  unsigned long paddr;
+  unsigned long size;
+
+  //address of left available memory in memory region
+  unsigned long free_mem;
+
+  //TODO: dynamically allocated memory
+  unsigned long* enclave_mem_metadata_page;
+
+  //root page table of enclave
+  unsigned long* root_page_table;
+  //root page table register for host
+  unsigned long host_ptbr;
+  //entry point of enclave
+  unsigned long entry_point;
+
+  unsigned long* ocall_func_id;
+  unsigned long* ocall_arg0;
+  unsigned long* ocall_arg1;
+  unsigned long* ocall_syscall_num;
+
+  //shared memory with host
+  unsigned long untrusted_ptr;
+  unsigned long untrusted_size;
+
+  //enclave thread context
+  //TODO: support multiple threads
+  struct thread_state_t thread_context;
+};
+
+struct cpu_state_t
+{
+  int in_enclave;
+  int eid;
+};
+
+uintptr_t copy_from_host(void* dest, void* src, size_t size);
+uintptr_t copy_to_host(void* dest, void* src, size_t size);
+
+uintptr_t create_enclave(struct enclave_sbi_param_t create_args);
+uintptr_t run_enclave(uintptr_t* regs, unsigned int eid);
+uintptr_t stop_enclave(uintptr_t* regs, unsigned int eid);
+uintptr_t resume_enclave(uintptr_t* regs, unsigned int eid);
+uintptr_t resume_from_stop(uintptr_t* regs, unsigned int eid);
+uintptr_t exit_enclave(uintptr_t* regs, unsigned long retval);
+uintptr_t do_timer_irq(uintptr_t* regs, uintptr_t mcause, uintptr_t mepc);
+
+#endif /* _ENCLAVE_H */
diff --git a/opensbi-0.9/include/sm/enclave_args.h b/opensbi-0.9/include/sm/enclave_args.h
new file mode 100644
index 000000000..6516f7079
--- /dev/null
+++ b/opensbi-0.9/include/sm/enclave_args.h
@@ -0,0 +1,31 @@
+#ifndef _ENCLAVE_ARGS_H
+#define _ENCLAVE_ARGS_H
+#include "thread.h"
+
+struct mm_alloc_arg_t
+{
+  unsigned long req_size;
+  uintptr_t resp_addr;
+  unsigned long resp_size;
+};
+
+/*
+ * enclave memory [paddr, paddr + size]
+ * free_mem @ unused memory address in enclave mem
+ */
+struct enclave_sbi_param_t
+{
+  unsigned int *eid_ptr;
+  unsigned long paddr;
+  unsigned long size;
+  unsigned long entry_point;
+  unsigned long untrusted_ptr;
+  unsigned long untrusted_size;
+  unsigned long free_mem;
+  unsigned long *ecall_arg0;
+  unsigned long *ecall_arg1;
+  unsigned long *ecall_arg2;
+  unsigned long *ecall_arg3;
+};
+
+#endif /* _ENCLAVE_ARGS_H */
diff --git a/opensbi-0.9/include/sm/ipi.h b/opensbi-0.9/include/sm/ipi.h
new file mode 100644
index 000000000..f2a012da3
--- /dev/null
+++ b/opensbi-0.9/include/sm/ipi.h
@@ -0,0 +1,21 @@
+#ifndef _IPI_H
+#define _IPI_H
+
+#include <sm/atomic.h>
+
+#define IPI_PMP_SYNC     0x1
+//#include <string.h>
+#include "stdint.h"
+struct ipi_mail_t
+{
+  uintptr_t event;
+  char data[40];
+};
+
+extern struct ipi_mail_t ipi_mail;
+
+extern spinlock_t ipi_mail_lock;
+
+void send_and_sync_ipi_mail(uintptr_t dest_hart);
+
+#endif /* _IPI_H */
diff --git a/opensbi-0.9/include/sm/math.h b/opensbi-0.9/include/sm/math.h
new file mode 100644
index 000000000..7a665b286
--- /dev/null
+++ b/opensbi-0.9/include/sm/math.h
@@ -0,0 +1,78 @@
+#ifndef _MATH_H
+#define _MATH_H
+
+#define ilog2(n)              \
+(                             \
+  (n) < 2 ? 0 :               \
+  (n) & (1ULL << 63) ? 63 :   \
+  (n) & (1ULL << 62) ? 62 :   \
+  (n) & (1ULL << 61) ? 61 :   \
+  (n) & (1ULL << 60) ? 60 :	  \
+  (n) & (1ULL << 59) ? 59 :	  \
+  (n) & (1ULL << 58) ? 58 :	  \
+  (n) & (1ULL << 57) ? 57 :	  \
+  (n) & (1ULL << 56) ? 56 :	  \
+  (n) & (1ULL << 55) ? 55 :	  \
+  (n) & (1ULL << 54) ? 54 :	  \
+  (n) & (1ULL << 53) ? 53 :	  \
+  (n) & (1ULL << 52) ? 52 :	  \
+  (n) & (1ULL << 51) ? 51 :	  \
+  (n) & (1ULL << 50) ? 50 :	  \
+  (n) & (1ULL << 49) ? 49 :	  \
+  (n) & (1ULL << 48) ? 48 :	  \
+  (n) & (1ULL << 47) ? 47 :	  \
+  (n) & (1ULL << 46) ? 46 :	  \
+  (n) & (1ULL << 45) ? 45 :	  \
+  (n) & (1ULL << 44) ? 44 :	  \
+  (n) & (1ULL << 43) ? 43 :	  \
+  (n) & (1ULL << 42) ? 42 :	  \
+  (n) & (1ULL << 41) ? 41 :	  \
+  (n) & (1ULL << 40) ? 40 :	  \
+  (n) & (1ULL << 39) ? 39 :	  \
+  (n) & (1ULL << 38) ? 38 :	  \
+  (n) & (1ULL << 37) ? 37 :	  \
+  (n) & (1ULL << 36) ? 36 :	  \
+  (n) & (1ULL << 35) ? 35 :	  \
+  (n) & (1ULL << 34) ? 34 :	  \
+  (n) & (1ULL << 33) ? 33 :	  \
+  (n) & (1ULL << 32) ? 32 :	  \
+  (n) & (1ULL << 31) ? 31 :	  \
+  (n) & (1ULL << 30) ? 30 :	  \
+  (n) & (1ULL << 29) ? 29 :	  \
+  (n) & (1ULL << 28) ? 28 :	  \
+  (n) & (1ULL << 27) ? 27 :	  \
+  (n) & (1ULL << 26) ? 26 :	  \
+  (n) & (1ULL << 25) ? 25 :	  \
+  (n) & (1ULL << 24) ? 24 :	  \
+  (n) & (1ULL << 23) ? 23 :	  \
+  (n) & (1ULL << 22) ? 22 :	  \
+  (n) & (1ULL << 21) ? 21 :	  \
+  (n) & (1ULL << 20) ? 20 :	  \
+  (n) & (1ULL << 19) ? 19 :	  \
+  (n) & (1ULL << 18) ? 18 :	  \
+  (n) & (1ULL << 17) ? 17 :	  \
+  (n) & (1ULL << 16) ? 16 :	  \
+  (n) & (1ULL << 15) ? 15 :	  \
+  (n) & (1ULL << 14) ? 14 :	  \
+  (n) & (1ULL << 13) ? 13 :	  \
+  (n) & (1ULL << 12) ? 12 :	  \
+  (n) & (1ULL << 11) ? 11 :	  \
+  (n) & (1ULL << 10) ? 10 :	  \
+  (n) & (1ULL <<  9) ?  9 :	  \
+  (n) & (1ULL <<  8) ?  8 :	  \
+  (n) & (1ULL <<  7) ?  7 :	  \
+  (n) & (1ULL <<  6) ?  6 :	  \
+  (n) & (1ULL <<  5) ?  5 :	  \
+  (n) & (1ULL <<  4) ?  4 :	  \
+  (n) & (1ULL <<  3) ?  3 :	  \
+  (n) & (1ULL <<  2) ?  2 :	  \
+  1                           \
+)
+
+#define power_2_align(n) (1 << (ilog2(n-1)+1))
+
+#define size_down_align(n, size) (n - ((n) % (size)))
+
+#define size_up_align(n, size) (size_down_align(n, size) + ((n) % (size) ? (size) : 0))
+
+#endif /* _MATH_H */
diff --git a/opensbi-0.9/include/sm/platform/spmp/enclave_mm.h b/opensbi-0.9/include/sm/platform/spmp/enclave_mm.h
new file mode 100644
index 000000000..4ceb05009
--- /dev/null
+++ b/opensbi-0.9/include/sm/platform/spmp/enclave_mm.h
@@ -0,0 +1,67 @@
+#ifndef _ENCLAVE_MM_H
+#define _ENCLAVE_MM_H
+
+#include <stdint.h>
+#include <sm/pmp.h>
+#include <sm/enclave.h>
+
+#define N_PMP_REGIONS (NPMP - 3)
+
+#define REGION_TO_PMP(region_idx) (region_idx + 1)
+#define PMP_TO_REGION(pmp_idx) (pmp_idx - 1)
+
+/*
+ * Layout of free memory chunk
+ * | struct mm_list_head_t | struct mm_list_t | 00...0 |
+ * | struct mm_list_head_t | struct mm_list_t | 00...0 |
+ * | struct mm_list_head_t | struct mm_list_t | 00...0 |
+ */
+struct mm_list_t
+{
+  int order;
+  struct mm_list_t *prev_mm;
+  struct mm_list_t *next_mm;
+};
+
+struct mm_list_head_t
+{
+  int order;
+  struct mm_list_head_t *prev_list_head;
+  struct mm_list_head_t *next_list_head;
+  struct mm_list_t *mm_list;
+};
+
+#define MM_LIST_2_PADDR(mm_list) ((void*)(mm_list) - sizeof(struct mm_list_head_t))
+#define PADDR_2_MM_LIST(paddr) ((void*)(paddr) + sizeof(struct mm_list_head_t))
+
+struct mm_region_t
+{
+  int valid;
+  uintptr_t paddr;
+  unsigned long size;
+  struct mm_list_head_t *mm_list_head;
+};
+
+#define region_overlap(pa0, size0, pa1, size1) (((pa0<=pa1) && ((pa0+size0)>pa1)) \
+    || ((pa1<=pa0) && ((pa1+size1)>pa0)))
+
+#define region_contain(pa0, size0, pa1, size1) (((unsigned long)(pa0) <= (unsigned long)(pa1)) \
+    && (((unsigned long)(pa0) + (unsigned long)(size0)) >= ((unsigned long)(pa1) + (unsigned long)(size1))))
+
+int grant_kernel_access(void* paddr, unsigned long size);
+
+int grant_enclave_access(struct enclave_t* enclave);
+
+int retrieve_kernel_access(void* paddr, unsigned long size);
+
+int retrieve_enclave_access(struct enclave_t *enclave);
+
+uintptr_t mm_init(uintptr_t paddr, unsigned long size);
+
+void* mm_alloc(unsigned long req_size, unsigned long* resp_size);
+
+int mm_free(void* paddr, unsigned long size);
+
+void print_buddy_system();
+
+#endif /* _ENCLAVE_MM_H */
diff --git a/opensbi-0.9/include/sm/platform/spmp/ipi_handler.h b/opensbi-0.9/include/sm/platform/spmp/ipi_handler.h
new file mode 100644
index 000000000..cf662b567
--- /dev/null
+++ b/opensbi-0.9/include/sm/platform/spmp/ipi_handler.h
@@ -0,0 +1,6 @@
+#ifndef _IPI_HANDLER_H
+#define _IPI_HANDLER_H
+
+void handle_ipi_mail();
+
+#endif /* _IPI_HANDLER_H */
diff --git a/opensbi-0.9/include/sm/platform/spmp/platform.h b/opensbi-0.9/include/sm/platform/spmp/platform.h
new file mode 100644
index 000000000..d09353fa7
--- /dev/null
+++ b/opensbi-0.9/include/sm/platform/spmp/platform.h
@@ -0,0 +1,11 @@
+#ifndef _PLATFORM_H
+#define _PLATFORM_H
+
+#include "spmp.h"
+#include "enclave_mm.h"
+#include "ipi_handler.h"
+#include "platform_thread.h"
+
+int platform_init();
+
+#endif /* _PLATFORM_H */
diff --git a/opensbi-0.9/include/sm/platform/spmp/platform_thread.h b/opensbi-0.9/include/sm/platform/spmp/platform_thread.h
new file mode 100644
index 000000000..ee306ba87
--- /dev/null
+++ b/opensbi-0.9/include/sm/platform/spmp/platform_thread.h
@@ -0,0 +1,18 @@
+#ifndef _PLATFORM_THREAD_H
+#define _PLATFORM_THREAD_H
+
+#include <sm/thread.h>
+
+void platform_enter_enclave_world();
+
+void platform_exit_enclave_world();
+
+int platform_check_in_enclave_world();
+
+int platform_check_enclave_authentication();
+
+void platform_switch_to_enclave_ptbr(struct thread_state_t* thread, uintptr_t ptbr);
+
+void platform_switch_to_host_ptbr(struct thread_state_t* thread, uintptr_t ptbr);
+
+#endif /* _PLATFORM_THREAD_H */
diff --git a/opensbi-0.9/include/sm/platform/spmp/spmp.h b/opensbi-0.9/include/sm/platform/spmp/spmp.h
new file mode 100644
index 000000000..c92627dd0
--- /dev/null
+++ b/opensbi-0.9/include/sm/platform/spmp/spmp.h
@@ -0,0 +1,85 @@
+#ifndef _SPMP_H
+#define _SPMP_H
+#define SPMP_ENABLED
+
+#include <stdint.h>
+#include <sbi/riscv_encoding.h>
+
+//number of PMP registers
+#define NSPMP 8
+
+//R/W/X/A/L field in PMP configuration registers
+#define SPMP_R     0x01
+#define SPMP_W     0x02
+#define SPMP_X     0x04
+#define SPMP_A     0x18
+#define SPMP_L     0x80
+
+//encoding of A field in PMP configuration registers
+#define SPMP_TOR   0x08
+#define SPMP_NA4   0x10
+#define SPMP_NAPOT 0x18
+#define SPMP_OFF   0x00
+#define SPMP_NO_PERM  0
+
+//encoding of csr code
+#define spmpaddr0        0x1b0
+#define spmpaddr1        0x1b1
+#define spmpaddr2        0x1b2
+#define spmpaddr3        0x1b3
+#define spmpaddr4        0x1b4
+#define spmpaddr5        0x1b5
+#define spmpaddr6        0x1b6
+#define spmpaddr7        0x1b7
+#define spmpcfg0         0x1a0
+
+//set to 1 when spmp trap happened, remember to clear it after handle the trap
+#define spmpexpt         0x145
+
+//read spmpcfg & spmpaddr
+#define read_spmpcfg(pmpc)   read_csr(pmpc)
+#define read_spmpaddr(addr)  read_csr(addr)
+#define read_spmpexpt(r)     read_csr(r)
+#define set_spmpexpt(r, v)   write_csr(r, v)
+
+//spmpfcg register's structure
+//|63    56|55    48|47    40|39    32|31    24|23    16|15     8|7      0|
+//|spmp7cfg|spmp6cfg|spmp5cfg|spmp4cfg|spmp3cfg|spmp2cfg|spmp1cfg|spmp1cfg|
+#define SPMP_PER_CFG_REG           8
+#define SPMPCFG_BIT_NUM            8
+#define SPMPCFG_BITS               0xFF
+
+#define _SPMP_SET(n, g, addr, pmpc) do { \
+  asm volatile ("la t0, 1f\n\t" \
+                "csrrw t0, mtvec, t0\n\t" \
+                "csrw "#n", %0\n\t" \
+                "csrw "#g", %1\n\t" \
+                "sfence.vma\n\t"\
+                ".align 2\n\t" \
+                "1: csrw mtvec, t0 \n\t" \
+                : : "r" (addr), "r" (pmpc) : "t0"); \
+} while(0)
+
+#define _SPMP_READ(n, g, addr, pmpc) do { \
+  asm volatile("csrr %0, "#n : "=r"(addr) :); \
+  asm volatile("csrr %0, "#g : "=r"(pmpc) :); \
+} while(0)
+
+#define SPMP_SET(n, g, addr, pmpc)  _SPMP_SET(n, g, addr, pmpc)
+#define SPMP_READ(n, g, addr, pmpc) _SPMP_READ(n, g, addr, pmpc)
+
+struct spmp_config_t
+{
+  uintptr_t paddr;
+  unsigned long size;
+  uintptr_t perm;
+  uintptr_t mode;
+};
+
+void set_spmp(int spmp_idx, struct spmp_config_t);
+
+void clear_spmp(int spmp_idx);
+
+struct spmp_config_t get_spmp(int spmp_idx);
+
+#endif /* _SPMP_H */
diff --git a/opensbi-0.9/include/sm/pmp.h b/opensbi-0.9/include/sm/pmp.h
new file mode 100644
index 000000000..fc9564ef1
--- /dev/null
+++ b/opensbi-0.9/include/sm/pmp.h
@@ -0,0 +1,72 @@
+#ifndef _PMP_H
+#define _PMP_H
+
+#include <stdint.h>
+#include "sbi/sbi_types.h"
+#include "sbi/riscv_encoding.h"
+#include "sbi/riscv_asm.h"
+
+//number of PMP registers
+#define NPMP 8
+
+//already defined in machine/encoding.h
+/*
+//R/W/X/A/L field in PMP configuration registers
+#define PMP_R     0x01
+#define PMP_W     0x02
+#define PMP_X     0x04
+#define PMP_A     0x18
+#define PMP_L     0x80
+
+//encoding of A field in PMP configuration registers
+#define PMP_TOR   0x08
+#define PMP_NA4   0x10
+#define PMP_NAPOT 0x18
+*/
+#define PMP_OFF   0x00
+#define PMP_NO_PERM  0
+
+//pmpfcg register's structure
+//|63     56|55     48|47     40|39     32|31     24|23     16|15      8|7       0|
+//| pmp7cfg | pmp6cfg | pmp5cfg | pmp4cfg | pmp3cfg | pmp2cfg | pmp1cfg | pmp1cfg |
+#define PMP_PER_CFG_REG           8
+#define PMPCFG_BIT_NUM            8
+#define PMPCFG_BITS               0xFF
+
+#define PMP_SET(num, cfg_index, pmpaddr, pmpcfg) do { \
+  uintptr_t oldcfg = csr_read(CSR_PMPCFG##cfg_index); \
+  pmpcfg |= (oldcfg & ~((uintptr_t)PMPCFG_BITS << (uintptr_t)PMPCFG_BIT_NUM*(num%PMP_PER_CFG_REG))); \
+  asm volatile ("la t0, 1f\n\t" \
+                "csrrw t0, mtvec, t0\n\t" \
+                "csrw pmpaddr"#num", %0\n\t" \
+                "csrw pmpcfg"#cfg_index", %1\n\t" \
+                "sfence.vma\n\t"\
+                ".align 2\n\t" \
+                "1: csrw mtvec, t0 \n\t" \
+                : : "r" (pmpaddr), "r" (pmpcfg) : "t0"); \
+} while(0)
+
+#define PMP_READ(num, cfg_index, pmpaddr, pmpcfg) do { \
+  asm volatile("csrr %0, pmpaddr"#num : "=r"(pmpaddr) :); \
+  asm volatile("csrr %0, pmpcfg"#cfg_index : "=r"(pmpcfg) :); \
+} while(0)
+
+struct pmp_config_t
+{
+  uintptr_t paddr;
+  unsigned long size;
+  uintptr_t perm;
+  uintptr_t mode;
+};
+
+void set_pmp_and_sync(int pmp_idx, struct pmp_config_t);
+
+void clear_pmp_and_sync(int pmp_idx);
+
+void set_pmp(int pmp_idx, struct pmp_config_t);
+
+void clear_pmp(int pmp_idx);
+
+struct pmp_config_t get_pmp(int pmp_idx);
+
+#endif /* _PMP_H */
diff --git a/opensbi-0.9/include/sm/print.h b/opensbi-0.9/include/sm/print.h
new file mode 100644
index 000000000..a5be1042e
--- /dev/null
+++ b/opensbi-0.9/include/sm/print.h
@@ -0,0 +1,9 @@
+#ifndef SM_PRINT_H
+#define SM_PRINT_H
+
+#include <sbi/sbi_console.h>
+
+#define printm(...) sbi_printf(__VA_ARGS__)
+
+#endif
+
diff --git a/opensbi-0.9/include/sm/sm.h b/opensbi-0.9/include/sm/sm.h
new file mode 100644
index 000000000..e6e8af85f
--- /dev/null
+++ b/opensbi-0.9/include/sm/sm.h
@@ -0,0 +1,75 @@
+#ifndef _SM_H
+#define _SM_H
+
+//#ifndef TARGET_PLATFORM_HEADER
+//#error "SM requires to specify a certain platform"
+//#endif
+
+//#include TARGET_PLATFORM_HEADER
+#include <sm/print.h>
+#include <sm/platform/spmp/platform.h>
+#include <stdint.h>
+#include <sm/enclave_args.h>
+#include <sm/ipi.h>
+
+#define SM_BASE 0x80000000
+#define SM_SIZE 0x200000
+
+#define MAX_HARTS 8
+
+//SBI_CALL NUMBERS
+#define SBI_MM_INIT            100
+#define SBI_CREATE_ENCLAVE      99
+#define SBI_ATTEST_ENCLAVE      98
+#define SBI_RUN_ENCLAVE         97
+#define SBI_STOP_ENCLAVE        96
+#define SBI_RESUME_ENCLAVE      95
+#define SBI_DESTROY_ENCLAVE     94
+#define SBI_ALLOC_ENCLAVE_MM    93
+#define SBI_MEMORY_EXTEND       92
+#define SBI_MEMORY_RECLAIM      91
+#define SBI_ENCLAVE_OCALL       90
+#define SBI_EXIT_ENCLAVE        89
+#define SBI_DEBUG_PRINT         88
+
+//Error code of SBI_ALLOC_ENCLAVE_MEM
+#define ENCLAVE_NO_MEMORY       -2
+#define ENCLAVE_ERROR           -1
+#define ENCLAVE_SUCCESS          0
+#define ENCLAVE_TIMER_IRQ        1
+
+//error code of SBI_RESUME_RNCLAVE
+#define RESUME_FROM_TIMER_IRQ    2000
+#define RESUME_FROM_STOP         2003
+
+void sm_init();
+
+uintptr_t sm_mm_init(uintptr_t paddr, unsigned long size);
+
+uintptr_t sm_mm_extend(uintptr_t paddr, unsigned long size);
+
+uintptr_t sm_alloc_enclave_mem(uintptr_t mm_alloc_arg);
+
+uintptr_t sm_create_enclave(uintptr_t enclave_create_args);
+
+uintptr_t sm_attest_enclave(uintptr_t enclave_id, uintptr_t report, uintptr_t nonce);
+
+uintptr_t sm_run_enclave(uintptr_t *regs, uintptr_t enclave_id);
+
+uintptr_t sm_debug_print(uintptr_t *regs, uintptr_t enclave_id);
+
+uintptr_t sm_stop_enclave(uintptr_t *regs, uintptr_t enclave_id);
+
+uintptr_t sm_resume_enclave(uintptr_t *regs, uintptr_t enclave_id);
+
+uintptr_t sm_destroy_enclave(uintptr_t *regs, uintptr_t enclave_id, uintptr_t destroy_flag);
+
+uintptr_t sm_enclave_ocall(uintptr_t *regs, uintptr_t ocall_func_id, uintptr_t arg);
+
+uintptr_t sm_exit_enclave(uintptr_t *regs, unsigned long retval);
+
+uintptr_t sm_do_timer_irq(uintptr_t *regs, uintptr_t mcause, uintptr_t mepc);
+
+int check_in_enclave_world();
+
+#endif /* _SM_H */
diff --git a/opensbi-0.9/include/sm/thread.h b/opensbi-0.9/include/sm/thread.h
new file mode 100644
index 000000000..1d3db9139
--- /dev/null
+++ b/opensbi-0.9/include/sm/thread.h
@@ -0,0 +1,86 @@
+#ifndef __THREAD_H__
+#define __THREAD_H__
+
+#include <stdint.h>
+
+//default layout of enclave
+//#####################
+//#   reserved for    #
+//#       s mode      #
+//##################### 0xffffffe000000000
+//#       hole        #
+//##################### 0x0000004000000000
+//#       stack       #
+//#                   #
+//#       heap        #
+//##################### 0x0000002000000000
+//#  untrusted memory #
+//#  shared with host #
+//##################### 0x0000001000000000
+//#     code & data   #
+//##################### 0x0000000000001000
+//#       hole        #
+//##################### 0x0
+
+#define ENCLAVE_DEFAULT_STACK 0x0000004000000000;
+
+#define N_GENERAL_REGISTERS 32
+
+struct general_registers_t
+{
+  uintptr_t slot;
+  uintptr_t ra;
+  uintptr_t sp;
+  uintptr_t gp;
+  uintptr_t tp;
+  uintptr_t t0;
+  uintptr_t t1;
+  uintptr_t t2;
+  uintptr_t s0;
+  uintptr_t s1;
+  uintptr_t a0;
+  uintptr_t a1;
+  uintptr_t a2;
+  uintptr_t a3;
+  uintptr_t a4;
+  uintptr_t a5;
+  uintptr_t a6;
+  uintptr_t a7;
+  uintptr_t s2;
+  uintptr_t s3;
+  uintptr_t s4;
+  uintptr_t s5;
+  uintptr_t s6;
+  uintptr_t s7;
+  uintptr_t s8;
+  uintptr_t s9;
+  uintptr_t s10;
+  uintptr_t s11;
+  uintptr_t t3;
+  uintptr_t t4;
+  uintptr_t t5;
+  uintptr_t t6;
+};
+
+/* enclave thread state */
+struct thread_state_t
+{
+  uintptr_t encl_ptbr;
+  uintptr_t prev_stvec;
+  uintptr_t prev_mie;
+  uintptr_t prev_mideleg;
+  uintptr_t prev_medeleg;
+  uintptr_t prev_mepc;
+  uintptr_t prev_cache_binding;
+  struct general_registers_t prev_state;
+};
+
+/* swap previous and current thread states */
+void swap_prev_state(struct thread_state_t* state, uintptr_t* regs);
+void swap_prev_mepc(struct thread_state_t* state, uintptr_t mepc);
+void swap_prev_stvec(struct thread_state_t* state, uintptr_t stvec);
+void swap_prev_cache_binding(struct thread_state_t* state, uintptr_t cache_binding);
+void swap_prev_mie(struct thread_state_t* state, uintptr_t mie);
+void swap_prev_mideleg(struct thread_state_t* state, uintptr_t mideleg);
+void swap_prev_medeleg(struct thread_state_t* state, uintptr_t medeleg);
+#endif /* thread */
diff --git a/opensbi-0.9/include/sm/vm.h b/opensbi-0.9/include/sm/vm.h
new file mode 100644
index 000000000..94ad8845e
--- /dev/null
+++ b/opensbi-0.9/include/sm/vm.h
@@ -0,0 +1,35 @@
+#ifndef _VM_H
+#define _VM_H
+
+#include <sbi/riscv_encoding.h>
+#include <stdint.h>
+
+#define MEGAPAGE_SIZE ((uintptr_t)(RISCV_PGSIZE << RISCV_PGLEVEL_BITS))
+#if __riscv_xlen == 64
+# define SATP_MODE_CHOICE INSERT_FIELD(0, SATP64_MODE, SATP_MODE_SV39)
+# define VA_BITS 39
+# define GIGAPAGE_SIZE (MEGAPAGE_SIZE << RISCV_PGLEVEL_BITS)
+#else
+# define SATP_MODE_CHOICE INSERT_FIELD(0, SATP32_MODE, SATP_MODE_SV32)
+# define VA_BITS 32
+#endif
+
+typedef uintptr_t pte_t;
+extern pte_t* root_page_table;
+
+static inline void flush_tlb()
+{
+  asm volatile ("sfence.vma");
+}
+
+static inline pte_t pte_create(uintptr_t ppn, int type)
+{
+  return (ppn << PTE_PPN_SHIFT) | PTE_V | type;
+}
+
+static inline pte_t ptd_create(uintptr_t ppn)
+{
+  return pte_create(ppn, PTE_V);
+}
+
+#endif
diff --git a/opensbi-0.9/lib/sbi/objects.mk b/opensbi-0.9/lib/sbi/objects.mk
index 6f2c06f5b..1e097ee1e 100644
--- a/opensbi-0.9/lib/sbi/objects.mk
+++ b/opensbi-0.9/lib/sbi/objects.mk
@@ -41,3 +41,17 @@ libsbi-objs-y += sbi_tlb.o
 libsbi-objs-y += sbi_trap.o
 libsbi-objs-y += sbi_unpriv.o
 libsbi-objs-y += sbi_expected_trap.o
+
+## Add by Dong Du
+#  The Penglai related files here
+libsbi-objs-y += sm/enclave.o
+libsbi-objs-y += sm/ipi.o
+libsbi-objs-y += sm/math.o
+libsbi-objs-y += sm/pmp.o
+libsbi-objs-y += sm/sm.o
+libsbi-objs-y += sm/thread.o
+#libsbi-objs-y += sm/platform/spmp/enclave_mm.o
+#libsbi-objs-y += sm/platform/spmp/ipi_handler.o
+libsbi-objs-y += sm/platform/spmp/platform.o
+#libsbi-objs-y += sm/platform/spmp/platform_thread.o
+#libsbi-objs-y += sm/platform/spmp/spmp.o
diff --git a/opensbi-0.9/lib/sbi/sbi_ecall.c b/opensbi-0.9/lib/sbi/sbi_ecall.c
index e92a53930..6338adee1 100644
--- a/opensbi-0.9/lib/sbi/sbi_ecall.c
+++ b/opensbi-0.9/lib/sbi/sbi_ecall.c
@@ -13,6 +13,9 @@
 #include <sbi/sbi_error.h>
 #include <sbi/sbi_trap.h>
 
+#include <sbi/riscv_asm.h>
+#include <sbi/riscv_encoding.h>
+
 u16 sbi_ecall_version_major(void)
 {
 	return SBI_ECALL_VERSION_MAJOR;
@@ -102,6 +105,15 @@ int sbi_ecall_handler(struct sbi_trap_regs *regs)
 	unsigned long out_val = 0;
 	bool is_0_1_spec = 0;
 
+	if (extension_id == SBI_EXT_BASE && func_id>80){
+		/* FIXME(DD): hacking, when extension id is base, put regs into last args
+		 * * currently this reg will not be used by any base functions
+		 */
+		sbi_printf("[PenglaiMonitor@%s] begin with mepc: 0x%x\n", __func__, regs->mepc);
+		//args[5] = (unsigned long) regs;
+		regs->mepc += 4;
+	}
+
 	ext = sbi_ecall_find_extension(extension_id);
 	if (ext && ext->handle) {
 		ret = ext->handle(extension_id, func_id,
@@ -116,6 +128,11 @@ int sbi_ecall_handler(struct sbi_trap_regs *regs)
 	if (ret == SBI_ETRAP) {
 		trap.epc = regs->mepc;
 		sbi_trap_redirect(regs, &trap);
+	} else if (extension_id == SBI_EXT_BASE && func_id>80){
+		regs->a0 = ret;
+		if (!is_0_1_spec)
+			regs->a1 = out_val;
+
 	} else {
 		if (ret < SBI_LAST_ERR) {
 			sbi_printf("%s: Invalid error %d for ext=0x%lx "
@@ -138,6 +155,13 @@ int sbi_ecall_handler(struct sbi_trap_regs *regs)
 			regs->a1 = out_val;
 	}
 
+	if (extension_id == SBI_EXT_BASE && func_id>80){
+		/* FIXME(DD): hacking, when extension id is base, put regs into last args
+		 * * currently this reg will not be used by any base functions
+		 */
+		sbi_printf("[PenglaiMonitor@%s] end with mepc: 0x%x\n", __func__, regs->mepc);
+	}
+
 	return 0;
 }
 
diff --git a/opensbi-0.9/lib/sbi/sbi_ecall_base.c b/opensbi-0.9/lib/sbi/sbi_ecall_base.c
index 786d2ac67..b93144480 100644
--- a/opensbi-0.9/lib/sbi/sbi_ecall_base.c
+++ b/opensbi-0.9/lib/sbi/sbi_ecall_base.c
@@ -15,6 +15,8 @@
 #include <sbi/sbi_version.h>
 #include <sbi/riscv_asm.h>
 
+#include <sbi/sbi_console.h>
+
 static int sbi_ecall_base_probe(unsigned long extid, unsigned long *out_val)
 {
 	struct sbi_ecall_extension *ext;
@@ -32,6 +34,14 @@ static int sbi_ecall_base_probe(unsigned long extid, unsigned long *out_val)
 	return 0;
 }
 
+/* Declare Penglai SM handlers here*/
+extern uintptr_t sm_mm_init(uintptr_t paddr, unsigned long size);
+extern uintptr_t sm_mm_extend(uintptr_t paddr, unsigned long size);
+extern uintptr_t sm_alloc_enclave_mem(uintptr_t mm_alloc_arg);
+extern uintptr_t sm_create_enclave(uintptr_t enclave_sbi_param);
+extern uintptr_t sm_run_enclave(uintptr_t* regs, unsigned long eid);
+extern uintptr_t sm_exit_enclave(uintptr_t* regs, unsigned long retval);
+
 static int sbi_ecall_base_handler(unsigned long extid, unsigned long funcid,
 				  const struct sbi_trap_regs *regs,
 				  unsigned long *out_val,
@@ -65,6 +75,25 @@ static int sbi_ecall_base_handler(unsigned long extid, unsigned long funcid,
 	case SBI_EXT_BASE_PROBE_EXT:
 		ret = sbi_ecall_base_probe(regs->a0, out_val);
 		break;
+	// The following is the Penglai's Handler
+	case SBI_MM_INIT:
+	  ret = sm_mm_init(regs->a0, regs->a1);
+	  break;
+	case SBI_MEMORY_EXTEND:
+	  ret = sm_mm_extend(regs->a0, regs->a1);
+	  break;
+	case SBI_ALLOC_ENCLAVE_MM:
+	  ret = sm_alloc_enclave_mem(regs->a0);
+	  break;
+	case SBI_CREATE_ENCLAVE:
+	  ret = sm_create_enclave(regs->a0);
+	  break;
+	case SBI_RUN_ENCLAVE:
+	  ret = sm_run_enclave((uintptr_t *)regs, regs->a0);
+	  break;
+	case SBI_EXIT_ENCLAVE:
+	  ret = sm_exit_enclave((uintptr_t *)regs, regs->a0);
+	  break;
 	default:
 		ret = SBI_ENOTSUPP;
 	}
diff --git a/opensbi-0.9/lib/sbi/sbi_init.c b/opensbi-0.9/lib/sbi/sbi_init.c
index 0e824588e..5e4231135 100644
--- a/opensbi-0.9/lib/sbi/sbi_init.c
+++ b/opensbi-0.9/lib/sbi/sbi_init.c
@@ -301,6 +301,8 @@ static void __noreturn init_coldboot(struct sbi_scratch *scratch, u32 hartid)
 
 	sbi_boot_print_hart(scratch, hartid);
 
+	sbi_printf("[Penglai] Penglai Enclave Preparing\n");
+
 	wake_coldboot_harts(scratch, hartid);
 
 	init_count = sbi_scratch_offset_ptr(scratch, init_count_offset);
diff --git a/opensbi-0.9/lib/sbi/sbi_trap.c b/opensbi-0.9/lib/sbi/sbi_trap.c
index b7349d2c9..24aaf72f6 100644
--- a/opensbi-0.9/lib/sbi/sbi_trap.c
+++ b/opensbi-0.9/lib/sbi/sbi_trap.c
@@ -194,6 +194,7 @@ int sbi_trap_redirect(struct sbi_trap_regs *regs,
 	return 0;
 }
 
+extern int check_in_enclave_world();
 /**
  * Handle trap/interrupt
  *
@@ -258,6 +259,12 @@ void sbi_trap_handler(struct sbi_trap_regs *regs)
 		msg = "ecall handler failed";
 		break;
 	default:
+		if (check_in_enclave_world() >=0) {
+			sbi_printf("[Penglai] ecall from enclaves\n");
+			rc = sbi_ecall_handler(regs);
+			msg = "ecall handler failed";
+			break;
+		}
 		/* If the trap came from S or U mode, redirect it there */
 		trap.epc = regs->mepc;
 		trap.cause = mcause;
diff --git a/opensbi-0.9/lib/sbi/sm/.gitignore b/opensbi-0.9/lib/sbi/sm/.gitignore
new file mode 100644
index 000000000..751553b3a
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/.gitignore
@@ -0,0 +1 @@
+*.bak
diff --git a/opensbi-0.9/lib/sbi/sm/enclave.c b/opensbi-0.9/lib/sbi/sm/enclave.c
new file mode 100644
index 000000000..6b8db393e
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/enclave.c
@@ -0,0 +1,713 @@
+#include <sm/print.h>
+#include <sm/enclave.h>
+#include <sm/sm.h>
+#include <sm/math.h>
+#include <sbi/riscv_encoding.h>
+//#include <string.h>
+#include <sbi/sbi_string.h>
+//#include TARGET_PLATFORM_HEADER
+#include <sm/platform/spmp/platform.h>
+
+static struct cpu_state_t cpus[MAX_HARTS] = {{0,}, };
+
+//spinlock
+static spinlock_t enclave_metadata_lock = SPINLOCK_INIT;
+
+//enclave metadata
+struct link_mem_t* enclave_metadata_head = NULL;
+struct link_mem_t* enclave_metadata_tail = NULL;
+
+uintptr_t copy_from_host(void* dest, void* src, size_t size)
+{
+  sbi_memcpy(dest, src, size);
+  return 0;
+}
+
+uintptr_t copy_to_host(void* dest, void* src, size_t size)
+{
+  sbi_memcpy(dest, src, size);
+  return 0;
+}
+
+int copy_word_to_host(unsigned int* ptr, uintptr_t value)
+{
+  *ptr = value;
+  return 0;
+}
+
+static void enter_enclave_world(int eid)
+{
+  cpus[csr_read(CSR_MHARTID)].in_enclave = ENCLAVE_MODE;
+  cpus[csr_read(CSR_MHARTID)].eid = eid;
+
+  platform_enter_enclave_world();
+}
+
+static int get_enclave_id()
+{
+  return cpus[csr_read(CSR_MHARTID)].eid;
+}
+
+static void exit_enclave_world()
+{
+  cpus[csr_read(CSR_MHARTID)].in_enclave = 0;
+  cpus[csr_read(CSR_MHARTID)].eid = -1;
+
+  platform_exit_enclave_world();
+}
+
+int check_in_enclave_world()
+{
+  if(!(cpus[csr_read(CSR_MHARTID)].in_enclave))
+    return -1;
+
+  if(platform_check_in_enclave_world() < 0)
+    return -1;
+
+  return 0;
+}
+
+static int check_enclave_authentication()
+{
+  if(platform_check_enclave_authentication() < 0)
+    return -1;
+
+  return 0;
+}
+
+static void switch_to_enclave_ptbr(struct thread_state_t* thread, uintptr_t ptbr)
+{
+  platform_switch_to_enclave_ptbr(thread, ptbr);
+}
+
+static void switch_to_host_ptbr(struct thread_state_t* thread, uintptr_t ptbr)
+{
+  platform_switch_to_host_ptbr(thread, ptbr);
+}
+
+struct link_mem_t* init_mem_link(unsigned long mem_size, unsigned long slab_size)
+{
+  struct link_mem_t* head;
+
+  head = (struct link_mem_t*)mm_alloc(mem_size, NULL);
+
+  if(head == NULL)
+    return NULL;
+  else
+    sbi_memset((void*)head, 0, mem_size);
+
+  head->mem_size = mem_size;
+  head->slab_size = slab_size;
+  head->slab_num = (mem_size - sizeof(struct link_mem_t)) / slab_size;
+  void* align_addr = (char*)head + sizeof(struct link_mem_t);
+  head->addr = (char*)size_up_align((unsigned long)align_addr, slab_size);
+  head->next_link_mem = NULL;
+
+  return head;
+}
+
+struct link_mem_t* add_link_mem(struct link_mem_t** tail)
+{
+  struct link_mem_t* new_link_mem;
+
+  new_link_mem = (struct link_mem_t*)mm_alloc((*tail)->mem_size, NULL);
+
+  if (new_link_mem == NULL)
+    return NULL;
+  else
+    sbi_memset((void*)new_link_mem, 0, (*tail)->mem_size);
+
+  (*tail)->next_link_mem = new_link_mem;
+  new_link_mem->mem_size = (*tail)->mem_size;
+  new_link_mem->slab_num = (*tail)->slab_num;
+  new_link_mem->slab_size = (*tail)->slab_size;
+  void* align_addr = (char*)new_link_mem + sizeof(struct link_mem_t);
+  new_link_mem->addr = (char*)size_up_align((unsigned long)align_addr, (*tail)->slab_size);
+  new_link_mem->next_link_mem = NULL;
+
+  return new_link_mem;
+}
+
+int remove_link_mem(struct link_mem_t** head, struct link_mem_t* ptr)
+{
+  struct link_mem_t *cur_link_mem, *tmp_link_mem;
+  int retval =0;
+
+  cur_link_mem = *head;
+  if (cur_link_mem == ptr)
+  {
+    *head = cur_link_mem->next_link_mem;
+    mm_free(cur_link_mem, cur_link_mem->mem_size);
+    return 1;
+  }
+
+  for(cur_link_mem; cur_link_mem != NULL; cur_link_mem = cur_link_mem->next_link_mem)
+  {
+    if (cur_link_mem->next_link_mem == ptr)
+    {
+      tmp_link_mem = cur_link_mem->next_link_mem;
+      cur_link_mem->next_link_mem = cur_link_mem->next_link_mem->next_link_mem;
+      //FIXME
+      mm_free(tmp_link_mem, tmp_link_mem->mem_size);
+      return retval;
+    }
+  }
+
+  return retval;
+}
+
+static struct enclave_t* alloc_enclave()
+{
+  struct link_mem_t *cur, *next;
+  struct enclave_t* enclave = NULL;
+  int i, found, eid;
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  //enclave metadata list hasn't be initialized yet
+  if(enclave_metadata_head == NULL)
+  {
+    enclave_metadata_head = init_mem_link(ENCLAVE_METADATA_REGION_SIZE, sizeof(struct enclave_t));
+    if(!enclave_metadata_head)
+    {
+      printm("M mode: alloc_enclave: don't have enough mem\r\n");
+      goto alloc_eid_out;
+    }
+    enclave_metadata_tail = enclave_metadata_head;
+  }
+
+  found = 0;
+  eid = 0;
+  for(cur = enclave_metadata_head; cur != NULL; cur = cur->next_link_mem)
+  {
+    for(i = 0; i < (cur->slab_num); i++)
+    {
+      enclave = (struct enclave_t*)(cur->addr) + i;
+      if(enclave->state == INVALID)
+      {
+        sbi_memset((void*)enclave, 0, sizeof(struct enclave_t));
+        enclave->state = FRESH;
+        enclave->eid = eid;
+        found = 1;
+        break;
+      }
+      eid++;
+    }
+    if(found)
+      break;
+  }
+
+  //don't have enough enclave metadata
+  if(!found)
+  {
+    next = add_link_mem(&enclave_metadata_tail);
+    if(next == NULL)
+    {
+      printm("M mode: alloc_enclave: don't have enough mem\r\n");
+      enclave = NULL;
+      goto alloc_eid_out;
+    }
+    enclave = (struct enclave_t*)(next->addr);
+    sbi_memset((void*)enclave, 0, sizeof(struct enclave_t));
+    enclave->state = FRESH;
+    enclave->eid = eid;
+  }
+
+alloc_eid_out:
+  spinlock_unlock(&enclave_metadata_lock);
+  return enclave;
+}
+
+static int free_enclave(int eid)
+{
+  struct link_mem_t *cur, *next;
+  struct enclave_t *enclave = NULL;
+  int i, found, count, ret_val;
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  found = 0;
+  count = 0;
+  for(cur = enclave_metadata_head; cur != NULL; cur = cur->next_link_mem)
+  {
+    if(eid < (count + cur->slab_num))
+    {
+      enclave = (struct enclave_t*)(cur->addr) + (eid - count);
+      sbi_memset((void*)enclave, 0, sizeof(struct enclave_t));
+      enclave->state = INVALID;
+      found = 1;
+      ret_val = 0;
+      break;
+    }
+    count += cur->slab_num;
+  }
+
+  //haven't alloc this eid
+  if(!found)
+  {
+    printm("M mode: free_enclave: haven't alloc this eid\r\n");
+    ret_val = -1;
+  }
+
+  spinlock_unlock(&enclave_metadata_lock);
+
+  return ret_val;
+}
+
+struct enclave_t* get_enclave(int eid)
+{
+  struct link_mem_t *cur, *next;
+  struct enclave_t *enclave;
+  int i, found, count;
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  found = 0;
+  count = 0;
+  for(cur = enclave_metadata_head; cur != NULL; cur = cur->next_link_mem)
+  {
+    if(eid < (count + cur->slab_num))
+    {
+      enclave = (struct enclave_t*)(cur->addr) + (eid - count);
+      found = 1;
+      break;
+    }
+
+    count += cur->slab_num;
+  }
+
+  //haven't alloc this eid
+  if(!found)
+  {
+    printm("M mode: get_enclave: haven't alloc this enclave\r\n");
+    enclave = NULL;
+  }
+
+  spinlock_unlock(&enclave_metadata_lock);
+  return enclave;
+}
+
+int swap_from_host_to_enclave(uintptr_t* host_regs, struct enclave_t* enclave)
+{
+  //grant encalve access to memory
+  if(grant_enclave_access(enclave) < 0)
+    return -1;
+
+  //save host context
+  swap_prev_state(&(enclave->thread_context), host_regs);
+
+  //different platforms have differnt ptbr switch methods
+  switch_to_enclave_ptbr(&(enclave->thread_context), enclave->thread_context.encl_ptbr);
+  printm("[Penglai@%s] switch ptbr:0x%x\n", __func__, enclave->thread_context.encl_ptbr);
+
+#if 0
+  //Note(DD): we do not need to save stvec?
+  //save host trap vector
+  swap_prev_stvec(&(enclave->thread_context), read_csr(stvec));
+#endif
+
+  //TODO: save host cache binding
+  //swap_prev_cache_binding(&enclave -> threads[0], read_csr(0x356));
+
+  //disable interrupts
+  swap_prev_mie(&(enclave->thread_context), csr_read(CSR_MIE));
+  csr_read_clear(CSR_MIP, MIP_MTIP);
+  csr_read_clear(CSR_MIP, MIP_STIP);
+  csr_read_clear(CSR_MIP, MIP_SSIP);
+  csr_read_clear(CSR_MIP, MIP_SEIP);
+
+  //disable interrupts/exceptions delegation
+  swap_prev_mideleg(&(enclave->thread_context), csr_read(CSR_MIDELEG));
+  swap_prev_medeleg(&(enclave->thread_context), csr_read(CSR_MEDELEG));
+
+  //swap the mepc to transfer control to the enclave
+  //swap_prev_mepc(&(enclave->thread_context), read_csr(mepc));
+  //Note(DD): we add 4 so that we directly switch back to the host thread
+#if 0
+  swap_prev_mepc(&(enclave->thread_context), read_csr(mepc));
+#endif
+
+#if 0 //Note(DD): put the code in outer function
+  //set mstatus to transfer control to u mode
+  uintptr_t mstatus = read_csr(mstatus);
+  mstatus = INSERT_FIELD(mstatus, MSTATUS_MPP, PRV_U);
+  write_csr(mstatus, mstatus);
+#endif
+
+  //mark that cpu is in enclave world now
+  enter_enclave_world(enclave->eid);
+
+  __asm__ __volatile__ ("sfence.vma" : : : "memory");
+
+  return 0;
+}
+
+int swap_from_enclave_to_host(uintptr_t* regs, struct enclave_t* enclave)
+{
+  //retrieve enclave access to memory
+  retrieve_enclave_access(enclave);
+
+  //restore host context
+  swap_prev_state(&(enclave->thread_context), regs);
+
+  //restore host's ptbr
+  switch_to_host_ptbr(&(enclave->thread_context), enclave->host_ptbr);
+
+  //restore host stvec
+#if 0
+  /* FIXME(DD): Not change stvec now */
+  swap_prev_stvec(&(enclave->thread_context), read_csr(stvec));
+#endif
+
+  //TODO: restore host cache binding
+  //swap_prev_cache_binding(&(enclave->thread_context), );
+
+  //restore interrupts
+  swap_prev_mie(&(enclave->thread_context), csr_read(CSR_MIE));
+
+  //restore interrupts/exceptions delegation
+  swap_prev_mideleg(&(enclave->thread_context), csr_read(CSR_MIDELEG));
+  swap_prev_medeleg(&(enclave->thread_context), csr_read(CSR_MEDELEG));
+
+  //transfer control back to kernel
+  //swap_prev_mepc(&(enclave->thread_context), read_csr(mepc));
+  regs[32] = (uintptr_t)(enclave->thread_context.prev_mepc); //In OpenSBI, we use regs to change mepc
+  swap_prev_mepc(&(enclave->thread_context), regs[32]);
+
+  //restore mstatus
+#if 0
+  uintptr_t mstatus = read_csr(mstatus);
+  mstatus = INSERT_FIELD(mstatus, MSTATUS_MPP, PRV_S);
+  write_csr(mstatus, mstatus);
+#else
+  uintptr_t mstatus = regs[33]; //In OpenSBI, we use regs to change mstatus
+  mstatus = INSERT_FIELD(mstatus, MSTATUS_MPP, PRV_S);
+  regs[33] = mstatus;
+#endif
+
+  //mark that cpu is out of enclave world now
+  exit_enclave_world();
+
+  __asm__ __volatile__ ("sfence.vma" : : : "memory");
+
+  return 0;
+}
+
+uintptr_t create_enclave(struct enclave_sbi_param_t create_args)
+{
+  struct enclave_t* enclave;
+
+  enclave = alloc_enclave();
+  if(!enclave)
+  {
+     printm("M mode: create_enclave: enclave allocation is failed \r\n");
+     return -1UL;
+  }
+
+  //TODO: check whether enclave memory is out of bound
+  //TODO: verify enclave page table layout
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  enclave->paddr = create_args.paddr;
+  enclave->size = create_args.size;
+  enclave->entry_point = create_args.entry_point;
+  enclave->untrusted_ptr = create_args.untrusted_ptr;
+  enclave->untrusted_size = create_args.untrusted_size;
+  enclave->free_mem = create_args.free_mem;
+  enclave->ocall_func_id = create_args.ecall_arg0;
+  enclave->ocall_arg0 = create_args.ecall_arg1;
+  enclave->ocall_arg1 = create_args.ecall_arg2;
+  enclave->ocall_syscall_num = create_args.ecall_arg3;
+  enclave->host_ptbr = csr_read(CSR_SATP);
+  enclave->thread_context.encl_ptbr = (create_args.paddr >> (RISCV_PGSHIFT) | SATP_MODE_CHOICE);
+  enclave->root_page_table = (unsigned long*)create_args.paddr;
+  enclave->state = FRESH;
+
+  spinlock_unlock(&enclave_metadata_lock);
+  printm("[Penglai@%s] paddr:0x%x, size:0x%x, entry:0x%x\n"
+		  "untrusted ptr:0x%x host_ptbr:0x%x, pt:0x%x\n"
+		  "thread_context.encl_ptbr:0x%lx\n cur_satp:0x%lx\n",
+		  __func__, enclave->paddr, enclave->size, enclave->entry_point,
+		  enclave->untrusted_ptr, enclave->host_ptbr, enclave->root_page_table,
+		  enclave->thread_context.encl_ptbr, csr_read(CSR_SATP));
+
+  copy_word_to_host((unsigned int*)create_args.eid_ptr, enclave->eid);
+  printm("[Penglai@%s] return eid:%d\n",
+		  __func__, enclave->eid);
+
+  return 0;
+}
+
+uintptr_t run_enclave(uintptr_t* regs, unsigned int eid)
+{
+  struct enclave_t* enclave;
+  uintptr_t retval = 0;
+  uintptr_t mstatus;
+
+  enclave = get_enclave(eid);
+  printm("M mode: run_enclave: flag: 1\r\n");
+  if(!enclave)
+  {
+    printm("M mode: run_enclave: wrong enclave id\r\n");
+    return -1UL;
+  }
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  printm("M mode: run_enclave: flag: 2\r\n");
+  if(enclave->state != FRESH)
+  {
+    printm("M mode: run_enclave: enclave is not initialized or already used\r\n");
+    retval = -1UL;
+    goto run_enclave_out;
+  }
+  printm("M mode: run_enclave: flag: 3\r\n");
+  if(enclave->host_ptbr != csr_read(CSR_SATP))
+  {
+    printm("M mode: run_enclave: enclave doesn't belong to current host process\r\n");
+    retval = -1UL;
+    goto run_enclave_out;
+  }
+
+  printm("M mode: run_enclave: flag: 4\r\n");
+  if(swap_from_host_to_enclave(regs, enclave) < 0)
+  {
+    printm("M mode: run_enclave: enclave can not be run\r\n");
+    retval = -1UL;
+    goto run_enclave_out;
+  }
+
+  printm("[Penglai Monitor@%s] save current mepc:0x%x\n",
+		  __func__, regs[32]);
+  swap_prev_mepc(&(enclave->thread_context), regs[32]);
+
+  //set return address to enclave
+  //write_csr(mepc, (uintptr_t)(enclave->entry_point));
+  regs[32] = (uintptr_t)(enclave->entry_point); //In OpenSBI, we use regs to change mepc
+  printm("M mode: run_enclave: flag: 5, mepc to:0x%x\r\n", regs[32]);
+
+  //set mstatus to transfer control to u mode
+  mstatus = regs[33]; //In OpenSBI, we use regs to change mstatus
+  mstatus = INSERT_FIELD(mstatus, MSTATUS_MPP, PRV_U);
+  regs[33] = mstatus;
+  //write_csr(mstatus, mstatus);
+
+  //TODO: enable timer interrupt
+  csr_read_set(CSR_MIE, MIP_MTIP);
+
+  //set default stack
+  regs[2] = ENCLAVE_DEFAULT_STACK;
+
+  //pass parameters
+  regs[11] = (uintptr_t)enclave->entry_point;
+  regs[12] = (uintptr_t)enclave->untrusted_ptr;
+  regs[13] = (uintptr_t)enclave->untrusted_size;
+
+  enclave->state = RUNNING;
+  printm("M mode: run_enclave: flag: 6, stack:0x%lx\r\n", regs[2]);
+
+run_enclave_out:
+  spinlock_unlock(&enclave_metadata_lock);
+  return retval;
+}
+
+uintptr_t stop_enclave(uintptr_t* regs, unsigned int eid)
+{
+  uintptr_t retval = 0;
+  struct enclave_t *enclave = get_enclave(eid);
+  if(!enclave)
+  {
+    printm("M mode: stop_enclave: wrong enclave id%d\r\n", eid);
+    return -1UL;
+  }
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  if(enclave->host_ptbr != csr_read(CSR_SATP))
+  {
+    printm("M mode: stop_enclave: enclave doesn't belong to current host process\r\n");
+    retval = -1UL;
+    goto stop_enclave_out;
+  }
+  if(enclave->state <= FRESH)
+  {
+    printm("M mode: stop_enclave: enclave%d hasn't begin running at all\r\n", eid);
+    retval = -1UL;
+    goto stop_enclave_out;
+  }
+  enclave->state = STOPPED;
+
+stop_enclave_out:
+  spinlock_unlock(&enclave_metadata_lock);
+  return retval;
+}
+
+uintptr_t resume_from_stop(uintptr_t* regs, unsigned int eid)
+{
+  uintptr_t retval = 0;
+  struct enclave_t* enclave = get_enclave(eid);
+  if(!enclave)
+  {
+    printm("M mode: resume_from_stop: wrong enclave id%d\r\n", eid);
+    return -1UL;
+  }
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  if(enclave->host_ptbr != csr_read(CSR_SATP))
+  {
+    printm("M mode: resume_from_stop: enclave doesn't belong to current host process\r\n");
+    retval = -1UL;
+    goto resume_from_stop_out;
+  }
+
+  if(enclave->state != STOPPED)
+  {
+    printm("M mode: resume_from_stop: enclave doesn't belong to current host process\r\n");
+    retval = -1UL;
+    goto resume_from_stop_out;
+  }
+
+  enclave->state = RUNNABLE;
+
+resume_from_stop_out:
+  spinlock_unlock(&enclave_metadata_lock);
+  return retval;
+}
+
+uintptr_t resume_enclave(uintptr_t* regs, unsigned int eid)
+{
+  uintptr_t retval = 0;
+  struct enclave_t* enclave = get_enclave(eid);
+  if(!enclave)
+  {
+    printm("M mode: resume_enclave: wrong enclave id%d\r\n", eid);
+    return -1UL;
+  }
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  if(enclave->host_ptbr != csr_read(CSR_SATP))
+  {
+    printm("M mode: resume_enclave: enclave doesn't belong to current host process\r\n");
+    retval = -1UL;
+    goto resume_enclave_out;
+  }
+
+  //TODO: check whether enclave is stopped or destroyed
+  if(enclave->state == STOPPED)
+  {
+    retval = ENCLAVE_TIMER_IRQ;
+    goto resume_enclave_out;
+  }
+  if(enclave->state == DESTROYED)
+  {
+    //TODO
+  }
+
+  if(enclave->state != RUNNABLE)
+  {
+    printm("M mode: resume_enclave: enclave%d is not runnable\r\n", eid);
+    retval = -1UL;
+    goto resume_enclave_out;
+  }
+
+  if(swap_from_host_to_enclave(regs, enclave) < 0)
+  {
+    printm("M mode: resume_enclave: enclave can not be run\r\n");
+    retval = -1UL;
+    goto resume_enclave_out;
+  }
+
+  enclave->state = RUNNING;
+
+  //regs[10] will be set to retval when mcall_trap return, so we have to
+  //set retval to be regs[10] here to succuessfully restore context
+  //TODO: retval should be set to indicate success or fail when resume from ocall
+  retval = regs[10];
+
+resume_enclave_out:
+  spinlock_unlock(&enclave_metadata_lock);
+  return retval;
+}
+
+uintptr_t exit_enclave(uintptr_t* regs, unsigned long retval)
+{
+  printm("M mode: exit_enclave: retval of enclave is %lx\r\n", retval);
+
+  struct enclave_t *enclave;
+  unsigned long paddr, size;
+  int i, eid;
+
+  if(check_in_enclave_world() < 0)
+  {
+    printm("M mode: exit_enclave: cpu is not in enclave world now\r\n");
+    return -1;
+  }
+
+  eid = get_enclave_id();
+  enclave = get_enclave(eid);
+  if(!enclave)
+  {
+    printm("M mode: exit_enclave: didn't find eid%d 's corresponding enclave\r\n", eid);
+    return -1UL;
+  }
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  if(check_enclave_authentication(enclave) < 0)
+  {
+    printm("M mode: exit_enclave: current enclave's eid is not %d\r\n", eid);
+    spinlock_unlock(&enclave_metadata_lock);
+    return -1UL;
+  }
+
+  swap_from_enclave_to_host(regs, enclave);
+
+  //free enclave's memory
+  //TODO: support multiple memory region
+  sbi_memset((void*)(enclave->paddr), 0, enclave->size);
+  mm_free((void*)(enclave->paddr), enclave->size);
+
+  spinlock_unlock(&enclave_metadata_lock);
+
+  //free enclave struct
+  free_enclave(eid);
+
+  return 0;
+}
+
+uintptr_t do_timer_irq(uintptr_t *regs, uintptr_t mcause, uintptr_t mepc)
+{
+  uintptr_t retval = 0;
+  unsigned int eid = get_enclave_id();
+  struct enclave_t *enclave = get_enclave(eid);
+  if(!enclave)
+  {
+    printm("M mode: something is wrong with enclave%d\r\n", eid);
+    return -1UL;
+  }
+
+  spinlock_lock(&enclave_metadata_lock);
+
+  //TODO: check whether this enclave is destroyed
+  if(enclave->state == DESTROYED)
+  {
+    //TODO
+  }
+
+  if(enclave->state != RUNNING && enclave->state != STOPPED)
+  {
+    printm("M mode: smething is wrong with enclave%d\r\n", eid);
+    retval = -1;
+    goto timer_irq_out;
+  }
+  swap_from_enclave_to_host(regs, enclave);
+  enclave->state = RUNNABLE;
+  regs[10] = ENCLAVE_TIMER_IRQ;
+
+timer_irq_out:
+  spinlock_unlock(&enclave_metadata_lock);
+  return retval;
+}
diff --git a/opensbi-0.9/lib/sbi/sm/ipi.c b/opensbi-0.9/lib/sbi/sm/ipi.c
new file mode 100644
index 000000000..8d44fb3c5
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/ipi.c
@@ -0,0 +1,54 @@
+//#include <sm/mtrap.h>
+//#include <sm/fdt.h>
+//#include <sm/disabled_hart_mask.h>
+#include <sm/ipi.h>
+
+//remember to acquire ipi_mail_lock before using this data struct
+struct ipi_mail_t ipi_mail = {0,};
+
+spinlock_t ipi_mail_lock = SPINLOCK_INIT;
+
+//remember to acquire ipi_mail_lock before using this function
+void send_and_sync_ipi_mail(uintptr_t dest_hart)
+{
+	/*
+	 * FIXME: we do not support this function now
+	 * */
+#if 0
+  //send IPIs to every other hart
+  uintptr_t mask = hart_mask;
+  mask &= dest_hart;
+  for(uintptr_t i=0, m = mask; m; ++i, m>>=1)
+  {
+    if((m & 1) && (!((disabled_hart_mask >> i) & 1))
+        && (i != read_csr(mhartid)))
+    {
+      //printm("hart%d: send to hart %d\r\n", read_csr(mhartid), i);
+      atomic_or(&OTHER_HLS(i)->mipi_pending, IPI_MAIL);
+      mb();
+      *OTHER_HLS(i)->ipi = 1;
+    }
+  }
+
+  //wait until all other harts have handled IPI
+  uintptr_t incoming_ipi = 0;
+  for(uintptr_t i=0, m=mask; m; ++i, m>>=1)
+  {
+    if((m & 1) && (!((disabled_hart_mask >> i) & 1))
+        && (i != read_csr(mhartid)))
+    {
+      while(*OTHER_HLS(i)->ipi)
+      {
+        incoming_ipi |= atomic_swap(HLS()->ipi, 0);
+      }
+    }
+  }
+
+  //if we got an IPI, restore it
+  if(incoming_ipi)
+  {
+    *HLS()->ipi = incoming_ipi;
+    mb();
+  }
+#endif
+}
diff --git a/opensbi-0.9/lib/sbi/sm/math.c b/opensbi-0.9/lib/sbi/sm/math.c
new file mode 100644
index 000000000..066413b4d
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/math.c
@@ -0,0 +1 @@
+#include <sm/math.h>
diff --git a/opensbi-0.9/lib/sbi/sm/platform/spmp/enclave_mm.c b/opensbi-0.9/lib/sbi/sm/platform/spmp/enclave_mm.c
new file mode 100644
index 000000000..ea4a506cd
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/platform/spmp/enclave_mm.c
@@ -0,0 +1,690 @@
+#include <sm/sm.h>
+#include <sm/enclave.h>
+#include <sm/platform/spmp/enclave_mm.h>
+#include <sm/atomic.h>
+//#include "mtrap.h"
+#include <sm/math.h>
+#include <sbi/sbi_string.h>
+
+/*
+ * Only NPMP-3 enclave regions are supported.
+ * The last PMP is used to allow kernel to access memory.
+ * The second to last PMP is used to protect security monitor from kernel.
+ * The first PMP is used to allow kernel to configure enclave's page table.
+ *
+ * TODO: this array can be removed as we can get
+ * existing enclave regions via pmp registers
+ */
+static struct mm_region_t mm_regions[N_PMP_REGIONS];
+static unsigned long pmp_bitmap = 0;
+static spinlock_t pmp_bitmap_lock = SPINLOCK_INIT;
+
+
+static int check_mem_size(uintptr_t paddr, unsigned long size)
+{
+  if((size == 0) || (size & (size - 1)))
+  {
+    printm("pmp size should be 2^power!\r\n");
+    return -1;
+  }
+
+  if(size < RISCV_PGSIZE)
+  {
+    printm("pmp size should be no less than one page!\r\n");
+    return -1;
+  }
+
+  if(paddr & (size - 1))
+  {
+    printm("pmp size should be %d aligned!\r\n", size);
+    return -1;
+  }
+
+  return 0;
+}
+
+/*
+ * This function grants kernel access to allocated enclave memory
+ * for initializing enclave and configuring page table.
+ */
+int grant_kernel_access(void* req_paddr, unsigned long size)
+{
+  //pmp0 is used for allowing kernel to access enclave memory
+  int pmp_idx = 0;
+  struct pmp_config_t pmp_config;
+  uintptr_t paddr = (uintptr_t)req_paddr;
+
+  if(check_mem_size(paddr, size) != 0)
+    return -1;
+
+  pmp_config.paddr = paddr;
+  pmp_config.size = size;
+  pmp_config.perm = PMP_R | PMP_W | PMP_X;
+  pmp_config.mode = PMP_A_NAPOT;
+  set_pmp_and_sync(pmp_idx, pmp_config);
+
+  return 0;
+}
+
+/*
+ * This function retrieves kernel access to allocated enclave memory.
+ */
+int retrieve_kernel_access(void* req_paddr, unsigned long size)
+{
+#if 0
+  //pmp0 is used for allowing kernel to access enclave memory
+  int pmp_idx = 0;
+  struct pmp_config_t pmp_config;
+  uintptr_t paddr = (uintptr_t)req_paddr;
+
+  pmp_config = get_pmp(pmp_idx);
+
+  if((pmp_config.mode != PMP_NAPOT) || (pmp_config.paddr != paddr) || (pmp_config.size != size))
+  {
+    printm("retrieve_kernel_access: error pmp_config\r\n");
+    return -1;
+  }
+
+  clear_pmp_and_sync(pmp_idx);
+
+  return 0;
+#else
+  //FIXME(DD): we always allow kernel access the memory now
+  return 0;
+#endif
+}
+
+//grant enclave access to enclave's memory
+int grant_enclave_access(struct enclave_t* enclave)
+{
+#if 0
+  int region_idx = 0;
+  int pmp_idx = 0;
+  struct pmp_config_t pmp_config;
+  struct spmp_config_t spmp_config;
+
+  if(check_mem_size(enclave->paddr, enclave->size) < 0)
+    return -1;
+
+  //set pmp permission, ensure that enclave's paddr and size is pmp legal
+  //TODO: support multiple memory regions
+  spinlock_lock(&pmp_bitmap_lock);
+  for(region_idx = 0; region_idx < N_PMP_REGIONS; ++region_idx)
+  {
+    if(mm_regions[region_idx].valid && region_contain(
+          mm_regions[region_idx].paddr, mm_regions[region_idx].size,
+          enclave->paddr, enclave->size))
+    {
+      break;
+    }
+  }
+  spinlock_unlock(&pmp_bitmap_lock);
+
+  if(region_idx >= N_PMP_REGIONS)
+  {
+    printm("M mode: grant_enclave_access: can not find exact mm_region\r\n");
+    return -1;
+  }
+
+  pmp_idx = REGION_TO_PMP(region_idx);
+  pmp_config.paddr = mm_regions[region_idx].paddr;
+  pmp_config.size = mm_regions[region_idx].size;
+  pmp_config.perm = PMP_R | PMP_W | PMP_X;
+  pmp_config.mode = PMP_NAPOT;
+  set_pmp(pmp_idx, pmp_config);
+
+  spmp_config.paddr = enclave->paddr;
+  spmp_config.size = enclave->size;
+  spmp_config.perm = SPMP_R | SPMP_W | SPMP_X;
+  spmp_config.mode = SPMP_NAPOT;
+  set_spmp(0, spmp_config);
+
+  spmp_config.paddr = mm_regions[region_idx].paddr;
+  spmp_config.size = mm_regions[region_idx].size;
+  spmp_config.perm = SPMP_NO_PERM;
+  spmp_config.mode = SPMP_NAPOT;
+  set_spmp(1, spmp_config);
+
+  return 0;
+#else
+  /* FIXME(DD): do nothing on PMP now */
+  return 0;
+#endif
+}
+
+int retrieve_enclave_access(struct enclave_t *enclave)
+{
+  int region_idx = 0;
+  int pmp_idx = 0;
+  struct pmp_config_t pmp_config;
+
+  //set pmp permission, ensure that enclave's paddr and size is pmp legal
+  //TODO: support multiple memory regions
+  spinlock_lock(&pmp_bitmap_lock);
+  for(region_idx = 0; region_idx < N_PMP_REGIONS; ++region_idx)
+  {
+    if(mm_regions[region_idx].valid && region_contain(
+          mm_regions[region_idx].paddr, mm_regions[region_idx].size,
+          enclave->paddr, enclave->size))
+    {
+      break;
+    }
+  }
+  spinlock_unlock(&pmp_bitmap_lock);
+
+#if 0 //FIXME(DD): disable PMP ops now
+  if(region_idx >= N_PMP_REGIONS)
+  {
+    printm("M mode: Error: retriece_enclave_access\r\n");
+    return -1;
+  }
+
+  pmp_idx = REGION_TO_PMP(region_idx);
+  pmp_config = get_pmp(pmp_idx);
+  pmp_config.perm = PMP_NO_PERM;
+  set_pmp(pmp_idx, pmp_config);
+
+  clear_spmp(0);
+  clear_spmp(1);
+#endif
+
+  return 0;
+}
+
+int check_mem_overlap(uintptr_t paddr, unsigned long size)
+{
+  unsigned long sm_base = SM_BASE;
+  unsigned long sm_size = SM_SIZE;
+  int region_idx = 0;
+
+  //check whether the new region overlaps with security monitor
+  if(region_overlap(sm_base, sm_size, paddr, size))
+  {
+    printm("pmp memory overlaps with security monitor!\r\n");
+    return -1;
+  }
+
+  //check whether the new region overlap with existing enclave region
+  for(region_idx = 0; region_idx < N_PMP_REGIONS; ++region_idx)
+  {
+    if(mm_regions[region_idx].valid
+        && region_overlap(mm_regions[region_idx].paddr, mm_regions[region_idx].size,
+          paddr, size))
+    {
+      printm("pmp memory overlaps with existing pmp memory!\r\n");
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+uintptr_t mm_init(uintptr_t paddr, unsigned long size)
+{
+  uintptr_t retval = 0;
+  int region_idx = 0;
+  int pmp_idx =0;
+  struct pmp_config_t pmp_config;
+
+  //check align of paddr and size
+  if(check_mem_size(paddr, size) < 0)
+    return -1UL;
+
+  //acquire a free enclave region
+  spinlock_lock(&pmp_bitmap_lock);
+
+  //check memory overlap
+  //memory overlap should be checked after acquire lock
+  if(check_mem_overlap(paddr, size) < 0)
+  {
+    retval = -1UL;
+    goto out;
+  }
+
+  //alloc a free pmp
+  for(region_idx = 0; region_idx < N_PMP_REGIONS; ++region_idx)
+  {
+    pmp_idx = REGION_TO_PMP(region_idx);
+    if(!(pmp_bitmap & (1<<pmp_idx)))
+    {
+      pmp_bitmap |= (1 << pmp_idx);
+      break;
+    }
+  }
+  if(region_idx >= N_PMP_REGIONS)
+  {
+    retval = -1UL;
+    goto out;
+  }
+
+  //set PMP to protect enclave memory region
+  pmp_config.paddr = paddr;
+  pmp_config.size = size;
+  pmp_config.perm = PMP_NO_PERM;
+  pmp_config.mode = PMP_A_NAPOT;
+  set_pmp_and_sync(pmp_idx, pmp_config);
+
+  //mark this region is valid and init mm_list
+  mm_regions[region_idx].valid = 1;
+  mm_regions[region_idx].paddr = paddr;
+  mm_regions[region_idx].size = size;
+  struct mm_list_t *mm_list = (struct mm_list_t*)PADDR_2_MM_LIST(paddr);
+  mm_list->order = ilog2(size-1) + 1;
+  mm_list->prev_mm = NULL;
+  mm_list->next_mm = NULL;
+  struct mm_list_head_t *mm_list_head = (struct mm_list_head_t*)paddr;
+  mm_list_head->order = mm_list->order;
+  mm_list_head->prev_list_head = NULL;
+  mm_list_head->next_list_head = NULL;
+  mm_list_head->mm_list = mm_list;
+  mm_regions[region_idx].mm_list_head = mm_list_head;
+
+out:
+  spinlock_unlock(&pmp_bitmap_lock);
+  return retval;
+}
+
+//NOTE: this function may modify the arg mm_list_head
+//remember to acquire lock before calling this function
+//be sure that mm_region does exist in mm_list and mm_list does exist in mm_lists
+static int delete_certain_region(int region_idx, struct mm_list_head_t** mm_list_head, struct mm_list_t *mm_region)
+{
+  struct mm_list_t* prev_mm = mm_region->prev_mm;
+  struct mm_list_t* next_mm = mm_region->next_mm;
+  struct mm_list_head_t* prev_list_head = (*mm_list_head)->prev_list_head;
+  struct mm_list_head_t* next_list_head = (*mm_list_head)->next_list_head;
+
+  //delete mm_region from old mm_list
+  //mm_region is in the middle of the mm_list
+  if(prev_mm)
+  {
+    prev_mm->next_mm = next_mm;
+    if(next_mm)
+      next_mm->prev_mm = prev_mm;
+  }
+  //mm_region is in the first place of old mm_list
+  else if(next_mm)
+  {
+    next_mm->prev_mm = NULL;
+    struct mm_list_head_t* new_list_head = (struct mm_list_head_t*)MM_LIST_2_PADDR(next_mm);
+    new_list_head->order = next_mm->order;
+    new_list_head->prev_list_head = prev_list_head;
+    new_list_head->next_list_head = next_list_head;
+    new_list_head->mm_list = next_mm;
+    if(prev_list_head)
+      prev_list_head->next_list_head = new_list_head;
+    else
+      mm_regions[region_idx].mm_list_head = new_list_head;
+    if(next_list_head)
+      next_list_head->prev_list_head = new_list_head;
+
+    *mm_list_head = new_list_head;
+  }
+  //mm_region is the only region in old mm_list
+  else
+  {
+    if(prev_list_head)
+      prev_list_head->next_list_head = next_list_head;
+    else
+      mm_regions[region_idx].mm_list_head = next_list_head;
+    if(next_list_head)
+      next_list_head->prev_list_head = prev_list_head;
+
+    *mm_list_head = NULL;
+  }
+
+  return 0;
+}
+
+//remember to acquire a lock before calling this function
+static struct mm_list_t* alloc_one_region(int region_idx, int order)
+{
+  if(!mm_regions[region_idx].valid || !mm_regions[region_idx].mm_list_head)
+  {
+    printm("M mode: alloc_one_region: m_regions[%d] is invalid/NULL\r\n", region_idx);
+    return NULL;
+  }
+
+  struct mm_list_head_t *mm_list_head = mm_regions[region_idx].mm_list_head;
+  while(mm_list_head && (mm_list_head->order < order))
+  {
+    mm_list_head = mm_list_head->next_list_head;
+  }
+
+  //current region has no enough free space
+  if(!mm_list_head)
+    return NULL;
+
+  //pick a mm region from current mm_list
+  struct mm_list_t *mm_region = mm_list_head->mm_list;
+
+  //delete the mm region from current mm_list
+  delete_certain_region(region_idx, &mm_list_head, mm_region);
+
+  return mm_region;
+}
+
+//remember to acquire lock before calling this function
+//be sure that mm_list_head does exist in mm_lists
+static int merge_regions(int region_idx, struct mm_list_head_t* mm_list_head, struct mm_list_t *mm_region)
+{
+  if(region_idx<0 || region_idx>=N_PMP_REGIONS || !mm_list_head || !mm_region)
+    return -1;
+  if(mm_list_head->order != mm_region->order)
+    return -1;
+
+  struct mm_list_head_t* current_list_head = mm_list_head;
+  struct mm_list_t* current_region = mm_region;
+  while(current_list_head)
+  {
+    struct mm_list_t* buddy_region = current_list_head->mm_list;
+    unsigned long paddr = (unsigned long)MM_LIST_2_PADDR(current_region);
+    unsigned long buddy_paddr = (unsigned long)MM_LIST_2_PADDR(buddy_region);
+    while(buddy_region)
+    {
+      buddy_paddr = (unsigned long)MM_LIST_2_PADDR(buddy_region);
+      if((paddr | (1 << current_region->order)) == (buddy_paddr | (1 << current_region->order)))
+        break;
+      buddy_region = buddy_region->next_mm;
+    }
+
+    struct mm_list_head_t* new_list_head = (struct mm_list_head_t*)MM_LIST_2_PADDR(current_region);
+    struct mm_list_head_t* prev_list_head = current_list_head->prev_list_head;
+    struct mm_list_head_t* next_list_head = current_list_head->next_list_head;
+    //didn't find buddy region, just insert this region in current mm_list
+    if(!buddy_region)
+    {
+      current_region->prev_mm = NULL;
+      current_region->next_mm = current_list_head->mm_list;
+      current_list_head->mm_list->prev_mm = current_region;
+      new_list_head->order = current_region->order;
+      new_list_head->prev_list_head = prev_list_head;
+      new_list_head->next_list_head = next_list_head;
+      new_list_head->mm_list = current_region;
+
+      if(prev_list_head)
+        prev_list_head->next_list_head = new_list_head;
+      else
+        mm_regions[region_idx].mm_list_head = new_list_head;
+      if(next_list_head)
+        next_list_head->prev_list_head = new_list_head;
+
+      break;
+    }
+
+    //found buddy_region, merge it and current region
+
+    //first delete buddy_region from old mm_list
+    //Note that this function may modify prev_list and next_list
+    //but won't modify their positions relative to new mm_region
+    delete_certain_region(region_idx, &current_list_head, buddy_region);
+
+    //then merge buddy_region with current region
+    int order = current_region->order;
+    current_region = paddr < buddy_paddr ? PADDR_2_MM_LIST(paddr) : PADDR_2_MM_LIST(buddy_paddr);
+    current_region->order = order + 1;
+    current_region->prev_mm = NULL;
+    current_region->next_mm = NULL;
+
+    //next mm_list doesn't exist or has a different order, no need to merge
+    if(!next_list_head || next_list_head->order != current_region->order)
+    {
+      //current_list_head may be NULL now after delete buddy region
+      if(current_list_head)
+        prev_list_head = current_list_head;
+      new_list_head = (struct mm_list_head_t*)MM_LIST_2_PADDR(current_region);
+      new_list_head->order = current_region->order;
+      new_list_head->prev_list_head = prev_list_head;
+      new_list_head->next_list_head = next_list_head;
+      new_list_head->mm_list = current_region;
+
+      if(prev_list_head)
+        prev_list_head->next_list_head = new_list_head;
+      else
+        mm_regions[region_idx].mm_list_head = new_list_head;
+      if(next_list_head)
+        next_list_head->prev_list_head = new_list_head;
+
+      break;
+    }
+
+    //continue to merge with next mm_list
+    current_list_head = next_list_head;
+  }
+
+  return 0;
+}
+
+//remember to acquire lock before calling this function
+static int insert_mm_region(int region_idx, struct mm_list_t* mm_region, int merge)
+{
+  if(region_idx<0 || region_idx>=N_PMP_REGIONS || !mm_regions[region_idx].valid || !mm_region)
+    return -1;
+
+  struct mm_list_head_t* mm_list_head = mm_regions[region_idx].mm_list_head;
+  struct mm_list_head_t* prev_list_head = NULL;
+
+  //there is no mm_list in current pmp_region
+  if(!mm_list_head)
+  {
+    mm_list_head = (struct mm_list_head_t*)MM_LIST_2_PADDR(mm_region);
+    mm_list_head->order = mm_region->order;
+    mm_list_head->prev_list_head = NULL;
+    mm_list_head->next_list_head = NULL;
+    mm_list_head->mm_list = mm_region;
+    mm_regions[region_idx].mm_list_head = mm_list_head;
+    return 0;
+  }
+
+  //traversal from front to back
+  while(mm_list_head && mm_list_head->order < mm_region->order)
+  {
+    prev_list_head = mm_list_head;
+    mm_list_head = mm_list_head->next_list_head;
+  }
+
+  //found the exact mm_list
+  int ret_val = 0;
+  struct mm_list_head_t *new_list_head = (struct mm_list_head_t*)MM_LIST_2_PADDR(mm_region);
+  if(mm_list_head && mm_list_head->order == mm_region->order)
+  {
+    if(!merge)
+    {
+      //insert mm_region to the first pos in mm_list
+      mm_region->prev_mm = NULL;
+      mm_region->next_mm = mm_list_head->mm_list;
+      mm_list_head->mm_list->prev_mm = mm_region;
+
+      //set mm_list_head
+      struct mm_list_head_t* next_list_head = mm_list_head->next_list_head;
+      new_list_head->order = mm_region->order;
+      new_list_head->prev_list_head = prev_list_head;
+      new_list_head->next_list_head = next_list_head;
+      new_list_head->mm_list = mm_region;
+      if(prev_list_head)
+        prev_list_head->next_list_head = new_list_head;
+      else
+        mm_regions[region_idx].mm_list_head = new_list_head;
+      if(next_list_head)
+        next_list_head->prev_list_head = new_list_head;
+    }
+    else
+    {
+      //insert with merge
+      ret_val = merge_regions(region_idx, mm_list_head, mm_region);
+    }
+  }
+  //should create a new mm_list for this mm region
+  //note that mm_list_head might be NULL
+  else
+  {
+    new_list_head->order = mm_region->order;
+    new_list_head->prev_list_head = prev_list_head;
+    new_list_head->next_list_head = mm_list_head;
+    new_list_head->mm_list = mm_region;
+    if(prev_list_head)
+      prev_list_head->next_list_head = new_list_head;
+    else
+      mm_regions[region_idx].mm_list_head = new_list_head;
+    if(mm_list_head)
+      mm_list_head->prev_list_head = new_list_head;
+  }
+
+  return ret_val;
+}
+
+//TODO: delete this function
+void print_buddy_system()
+{
+  //spinlock_lock(&pmp_bitmap_lock);
+
+  struct mm_list_head_t* mm_list_head = mm_regions[0].mm_list_head;
+  printm("struct mm_list_head_t size is 0x%lx\r\n", sizeof(struct mm_list_head_t));
+  printm("struct mm_list_t size is 0x%lx\r\n", sizeof(struct mm_list_t));
+  while(mm_list_head)
+  {
+    printm("mm_list_head addr is 0x%lx, order is %d\r\n", mm_list_head, mm_list_head->order);
+    printm("mm_list_head prev is 0x%lx, next is 0x%lx, mm_list is 0x%lx\r\n", mm_list_head->prev_list_head, mm_list_head->next_list_head, mm_list_head->mm_list);
+    struct mm_list_t *mm_region = mm_list_head->mm_list;
+    while(mm_region)
+    {
+      printm("  mm_region addr is 0x%lx, order is %d\r\n", mm_region, mm_region->order);
+      printm("  mm_region prev is 0x%lx, next is 0x%lx\r\n", mm_region->prev_mm, mm_region->next_mm);
+      mm_region = mm_region->next_mm;
+    }
+    mm_list_head = mm_list_head->next_list_head;
+  }
+
+  //spinlock_unlock(&pmp_bitmap_lock);
+}
+
+void* mm_alloc(unsigned long req_size, unsigned long *resp_size)
+{
+  void* ret_addr = NULL;
+  if(req_size == 0)
+    return ret_addr;
+
+  //TODO: reduce lock granularity
+  spinlock_lock(&pmp_bitmap_lock);
+
+  //printm("before mm_alloc, req_order = %d\r\n", ilog2(req_size - 1) + 1);
+  //print_buddy_system();
+
+  unsigned long order = ilog2(req_size-1) + 1;
+  for(int region_idx=0; region_idx < N_PMP_REGIONS; ++region_idx)
+  {
+    struct mm_list_t* mm_region = alloc_one_region(region_idx, order);
+
+    //there is no enough space in current pmp region
+    if(!mm_region)
+      continue;
+
+    while(mm_region->order > order)
+    {
+      //allocated mm region need to be split
+      mm_region->order -= 1;
+      mm_region->prev_mm = NULL;
+      mm_region->next_mm = NULL;
+
+      void* new_mm_region_paddr = MM_LIST_2_PADDR(mm_region) + (1 << mm_region->order);
+      struct mm_list_t* new_mm_region = PADDR_2_MM_LIST(new_mm_region_paddr);
+      new_mm_region->order = mm_region->order;
+      new_mm_region->prev_mm = NULL;
+      new_mm_region->next_mm = NULL;
+      insert_mm_region(region_idx, new_mm_region, 0);
+    }
+
+    ret_addr = MM_LIST_2_PADDR(mm_region);
+    break;
+  }
+
+  //printm("after mm_alloc\r\n");
+  //print_buddy_system();
+
+  spinlock_unlock(&pmp_bitmap_lock);
+
+  if(ret_addr && resp_size)
+  {
+    *resp_size = 1 << order;
+    sbi_memset(ret_addr, 0, *resp_size);
+  }
+
+  return ret_addr;
+}
+
+int mm_free(void* req_paddr, unsigned long free_size)
+{
+  //check this paddr is 2^power aligned
+  uintptr_t paddr = (uintptr_t)req_paddr;
+  unsigned long order = ilog2(free_size-1) + 1;
+  unsigned long size = 1 << order;
+  if(check_mem_size(paddr, size) < 0)
+    return -1;
+
+  int ret_val = 0;
+  int region_idx = 0;
+  struct mm_list_t* mm_region = PADDR_2_MM_LIST(paddr);
+  mm_region->order = order;
+  mm_region->prev_mm = NULL;
+  mm_region->next_mm = NULL;
+
+  spinlock_lock(&pmp_bitmap_lock);
+
+  //printm("before mm_free, addr to free is 0x%lx, order is %d\r\n", paddr, order);
+  //print_buddy_system();
+
+  for(region_idx=0; region_idx < N_PMP_REGIONS; ++region_idx)
+  {
+    if(mm_regions[region_idx].valid && region_contain(mm_regions[region_idx].paddr, mm_regions[region_idx].size, paddr, size))
+    {
+      break;
+    }
+  }
+  if(region_idx >= N_PMP_REGIONS)
+  {
+    printm("mm_free: buddy system doesn't contain memory(addr 0x%lx, order %d)\r\n", paddr, order);
+    ret_val = -1;
+    goto mm_free_out;
+  }
+
+  //check whether this region overlap with existing free mm_lists
+  struct mm_list_head_t* mm_list_head = mm_regions[region_idx].mm_list_head;
+  while(mm_list_head)
+  {
+    struct mm_list_t* mm_region = mm_list_head->mm_list;
+    while(mm_region)
+    {
+      uintptr_t region_paddr = (uintptr_t)MM_LIST_2_PADDR(mm_region);
+      unsigned long region_size = 1 << mm_region->order;
+      if(region_overlap(paddr, size, region_paddr, region_size))
+      {
+        printm("mm_free: memory(addr 0x%lx order %d) overlap with free memory(addr 0x%lx order %d)\r\n", paddr, order, region_paddr, mm_region->order);
+        ret_val = -1;
+        break;
+      }
+      mm_region = mm_region->next_mm;
+    }
+    if(mm_region)
+      break;
+
+    mm_list_head = mm_list_head->next_list_head;
+  }
+  if(mm_list_head)
+  {
+    goto mm_free_out;
+  }
+
+  //insert with merge
+  ret_val = insert_mm_region(region_idx, mm_region, 1);
+  if(ret_val < 0)
+  {
+    printm("mm_free: failed to insert mm(addr 0x%lx, order %d)\r\n in mm_regions[%d]\r\n", paddr, order, region_idx);
+  }
+
+  //printm("after mm_free\r\n");
+  //print_buddy_system();
+
+mm_free_out:
+  spinlock_unlock(&pmp_bitmap_lock);
+  return ret_val;
+}
diff --git a/opensbi-0.9/lib/sbi/sm/platform/spmp/ipi_handler.c b/opensbi-0.9/lib/sbi/sm/platform/spmp/ipi_handler.c
new file mode 100644
index 000000000..83b868f24
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/platform/spmp/ipi_handler.c
@@ -0,0 +1,21 @@
+#include <sm/ipi.h>
+#include <sm/pmp.h>
+
+void handle_ipi_mail()
+{
+  char* mail_data = ipi_mail.data;
+  int pmp_idx = 0;
+  struct pmp_config_t pmp_config;
+  //printm("hart%d: handle ipi event%x\r\n", read_csr(mhartid), ipi_mail.event);
+
+  switch(ipi_mail.event)
+  {
+    case IPI_PMP_SYNC:
+      pmp_config = *(struct pmp_config_t*)(ipi_mail.data);
+      pmp_idx = *(int*)((void*)ipi_mail.data + sizeof(struct pmp_config_t));
+      set_pmp(pmp_idx, pmp_config);
+      break;
+    default:
+        break;
+  }
+}
diff --git a/opensbi-0.9/lib/sbi/sm/platform/spmp/platform.c b/opensbi-0.9/lib/sbi/sm/platform/spmp/platform.c
new file mode 100644
index 000000000..b8132322f
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/platform/spmp/platform.c
@@ -0,0 +1,42 @@
+#include "spmp.c"
+#include "enclave_mm.c"
+#include "ipi_handler.c"
+#include "platform_thread.c"
+
+#include <sm/print.h>
+
+int platform_init()
+{
+  //Clear pmp0, this pmp is reserved for allowing kernel
+  //to config page table for enclave in enclave's memory.
+  //There is no need to broadcast to other hart as every
+  //hart will execute this function.
+  clear_pmp(0);
+
+  //config the last PMP to allow kernel to access memory
+  struct pmp_config_t pmp_config;
+  pmp_config.paddr = 0;
+  pmp_config.size = -1UL;
+  pmp_config.mode = PMP_A_NAPOT;
+  pmp_config.perm = PMP_R | PMP_W | PMP_X;
+  set_pmp(NPMP-1, pmp_config);
+
+  //config the last PMP to protect security monitor
+  pmp_config.paddr = (uintptr_t)SM_BASE;
+  pmp_config.size = (unsigned long)SM_SIZE;
+  pmp_config.mode = PMP_A_NAPOT;
+  pmp_config.perm = PMP_NO_PERM;
+  set_pmp(NPMP-2, pmp_config);
+
+  printm("[Penglai Monitor@%s] PMP is ready, now setup sPMP\n", __func__);
+
+  //config the last sPMP to allow user to access memory
+  struct spmp_config_t spmp_config;
+  spmp_config.paddr = 0;
+  spmp_config.size = -1UL;
+  spmp_config.mode = SPMP_NAPOT;
+  spmp_config.perm = SPMP_R | SPMP_W | SPMP_X;
+  set_spmp(NSPMP-1, spmp_config);
+
+  return 0;
+}
diff --git a/opensbi-0.9/lib/sbi/sm/platform/spmp/platform_thread.c b/opensbi-0.9/lib/sbi/sm/platform/spmp/platform_thread.c
new file mode 100644
index 000000000..eb8e68068
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/platform/spmp/platform_thread.c
@@ -0,0 +1,34 @@
+void platform_enter_enclave_world()
+{
+  //TODO: add register to indicate whether in encalve world or not
+  return;
+}
+
+void platform_exit_enclave_world()
+{
+  //TODO: add register to indicate whether in encalve world or not
+  return;
+}
+
+int platform_check_in_enclave_world()
+{
+  //TODO: add register to indicate whether in encalve world or not
+  return 0;
+}
+
+int platform_check_enclave_authentication(struct enclave_t* enclave)
+{
+  if(enclave->thread_context.encl_ptbr != csr_read(CSR_SATP))
+    return -1;
+  return 0;
+}
+
+void platform_switch_to_enclave_ptbr(struct thread_state_t* thread, uintptr_t enclave_ptbr)
+{
+  csr_write(CSR_SATP, enclave_ptbr);
+}
+
+void platform_switch_to_host_ptbr(struct thread_state_t* thread, uintptr_t host_ptbr)
+{
+  csr_write(CSR_SATP, host_ptbr);
+}
diff --git a/opensbi-0.9/lib/sbi/sm/platform/spmp/spmp.c b/opensbi-0.9/lib/sbi/sm/platform/spmp/spmp.c
new file mode 100644
index 000000000..2ce3fcdc0
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/platform/spmp/spmp.c
@@ -0,0 +1,171 @@
+#include <sm/platform/spmp/spmp.h>
+#include <sm/ipi.h>
+#include <stddef.h>
+
+void set_spmp(int spmp_idx, struct spmp_config_t spmp_cfg_t)
+{
+#if 0
+  uintptr_t spmp_address = 0;
+  uintptr_t old_config = 0;
+  uintptr_t spmp_config = ((spmp_cfg_t.mode & SPMP_A) | (spmp_cfg_t.perm & (SPMP_R|SPMP_W|SPMP_X)))
+    << ((uintptr_t)SPMPCFG_BIT_NUM * (spmp_idx % SPMP_PER_CFG_REG));
+
+  switch(spmp_cfg_t.mode)
+  {
+    case SPMP_NAPOT:
+      if(spmp_cfg_t.paddr == 0 && spmp_cfg_t.size == -1UL)
+        spmp_address = -1UL;
+      else
+        spmp_address = (spmp_cfg_t.paddr | ((spmp_cfg_t.size>>1)-1)) >> 2;
+      break;
+    case SPMP_TOR:
+      spmp_address = spmp_cfg_t.paddr;
+    case SPMP_NA4:
+      spmp_address = spmp_cfg_t.paddr;
+    case SPMP_OFF:
+      spmp_address = 0;
+    default:
+      break;
+  }
+
+  switch(spmp_idx)
+  {
+    case 0:
+      old_config = read_spmpcfg(spmpcfg0);
+      spmp_config |= (old_config &
+          ~((uintptr_t)SPMPCFG_BITS << (uintptr_t)SPMPCFG_BIT_NUM*(0%SPMP_PER_CFG_REG)));
+      SPMP_SET(spmpaddr0, spmpcfg0, spmp_address, spmp_config);
+      break;
+    case 1:
+      old_config = read_spmpcfg(spmpcfg0);
+      spmp_config |= (old_config &
+          ~((uintptr_t)SPMPCFG_BITS << (uintptr_t)SPMPCFG_BIT_NUM*(1%SPMP_PER_CFG_REG)));
+      SPMP_SET(spmpaddr1, spmpcfg0, spmp_address, spmp_config);
+     break;
+    case 2:
+      old_config = read_spmpcfg(spmpcfg0);
+      spmp_config |= (old_config &
+          ~((uintptr_t)SPMPCFG_BITS << (uintptr_t)SPMPCFG_BIT_NUM*(2%SPMP_PER_CFG_REG)));
+      SPMP_SET(spmpaddr2, spmpcfg0, spmp_address, spmp_config);
+     break;
+    case 3:
+      old_config = read_spmpcfg(spmpcfg0);
+      spmp_config |= (old_config &
+          ~((uintptr_t)SPMPCFG_BITS << (uintptr_t)SPMPCFG_BIT_NUM*(3%SPMP_PER_CFG_REG)));
+      SPMP_SET(spmpaddr3, spmpcfg0, spmp_address, spmp_config);
+     break;
+    case 4:
+      old_config = read_spmpcfg(spmpcfg0);
+      spmp_config |= (old_config &
+          ~((uintptr_t)SPMPCFG_BITS << (uintptr_t)SPMPCFG_BIT_NUM*(4%SPMP_PER_CFG_REG)));
+      SPMP_SET(spmpaddr4, spmpcfg0, spmp_address, spmp_config);
+     break;
+    case 5:
+      old_config = read_spmpcfg(spmpcfg0);
+      spmp_config |= (old_config &
+          ~((uintptr_t)SPMPCFG_BITS << (uintptr_t)SPMPCFG_BIT_NUM*(5%SPMP_PER_CFG_REG)));
+      SPMP_SET(spmpaddr5, spmpcfg0, spmp_address, spmp_config);
+     break;
+    case 6:
+      old_config = read_spmpcfg(spmpcfg0);
+      spmp_config |= (old_config &
+          ~((uintptr_t)SPMPCFG_BITS << (uintptr_t)SPMPCFG_BIT_NUM*(6%SPMP_PER_CFG_REG)));
+      SPMP_SET(spmpaddr6, spmpcfg0, spmp_address, spmp_config);
+     break;
+    case 7:
+      old_config = read_spmpcfg(spmpcfg0);
+      spmp_config |= (old_config &
+          ~((uintptr_t)SPMPCFG_BITS << (uintptr_t)SPMPCFG_BIT_NUM*(7%SPMP_PER_CFG_REG)));
+      SPMP_SET(spmpaddr7, spmpcfg0, spmp_address, spmp_config);
+     break;
+    default:
+      break;
+  }
+#endif
+  return;
+}
+
+void clear_spmp(int spmp_idx)
+{
+#if 0
+  struct spmp_config_t spmp_cfg;
+
+  spmp_cfg.mode = SPMP_OFF;
+  spmp_cfg.perm = SPMP_NO_PERM;
+  spmp_cfg.paddr = 0;
+  spmp_cfg.size = 0;
+  set_spmp(spmp_idx, spmp_cfg);
+#endif
+  return;
+}
+
+struct spmp_config_t get_spmp(int spmp_idx)
+{
+  struct spmp_config_t spmp={0,};
+#if 0
+  uintptr_t spmp_address = 0;
+  uintptr_t spmp_config = 0;
+  unsigned long order = 0;
+  unsigned long size = 0;
+
+  switch(spmp_idx)
+  {
+    case 0:
+      SPMP_READ(spmpaddr0, spmpcfg0, spmp_address, spmp_config);
+      break;
+    case 1:
+      SPMP_READ(spmpaddr1, spmpcfg0, spmp_address, spmp_config);
+      break;
+    case 2:
+      SPMP_READ(spmpaddr2, spmpcfg0, spmp_address, spmp_config);
+      break;
+    case 3:
+      SPMP_READ(spmpaddr3, spmpcfg0, spmp_address, spmp_config);
+      break;
+    case 4:
+      SPMP_READ(spmpaddr4, spmpcfg0, spmp_address, spmp_config);
+      break;
+    case 5:
+      SPMP_READ(spmpaddr5, spmpcfg0, spmp_address, spmp_config);
+      break;
+    case 6:
+      SPMP_READ(spmpaddr6, spmpcfg0, spmp_address, spmp_config);
+      break;
+    case 7:
+      SPMP_READ(spmpaddr7, spmpcfg0, spmp_address, spmp_config);
+      break;
+    default:
+      break;
+  }
+
+  spmp_config >>= (uintptr_t)SPMPCFG_BIT_NUM * (spmp_idx % SPMP_PER_CFG_REG);
+  spmp_config &= SPMPCFG_BITS;
+  switch(spmp_config & SPMP_A)
+  {
+    case SPMP_NAPOT:
+      while(spmp_address & 1)
+      {
+        order += 1;
+        spmp_address >>= 1;
+      }
+      order += 3;
+      size = 1 << order;
+      spmp_address <<= (order-1);
+      break;
+    case SPMP_NA4:
+      size = 4;
+    case SPMP_TOR:
+      break;
+    case SPMP_OFF:
+      spmp_address = 0;
+      size = 0;
+      break;
+  }
+
+  spmp.mode = spmp_config & SPMP_A;
+  spmp.perm = spmp_config & (SPMP_R | SPMP_W | SPMP_X);
+  spmp.paddr = spmp_address;
+  spmp.size = size;
+#endif
+  return spmp;
+}
diff --git a/opensbi-0.9/lib/sbi/sm/pmp.c b/opensbi-0.9/lib/sbi/sm/pmp.c
new file mode 100644
index 000000000..e73e9bca2
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/pmp.c
@@ -0,0 +1,191 @@
+#include <sm/pmp.h>
+#include <sm/ipi.h>
+#include <stddef.h>
+
+//set pmp and sync all harts
+void set_pmp_and_sync(int pmp_idx_arg, struct pmp_config_t pmp_config_arg)
+{
+#if 0//by Dd, disable PMP Op
+  struct pmp_config_t* pmp_config = NULL;
+  int* pmp_idx = NULL;
+
+  spinlock_lock(&ipi_mail_lock);
+
+  //set current hart's pmp
+  set_pmp(pmp_idx_arg, pmp_config_arg);
+  //sync all other harts
+  ipi_mail.event = IPI_PMP_SYNC;
+  pmp_config = (void*)ipi_mail.data;
+  pmp_idx = (void*)ipi_mail.data + sizeof(struct pmp_config_t);
+  *pmp_config = pmp_config_arg;
+  *pmp_idx = pmp_idx_arg;
+
+  send_and_sync_ipi_mail(0xFFFFFFFF);
+
+  spinlock_unlock(&ipi_mail_lock);
+#endif
+
+  return;
+}
+
+//clear pmp and sync all harts
+void clear_pmp_and_sync(int pmp_idx)
+{
+  struct pmp_config_t pmp_config = {0,};
+
+  pmp_config.mode = PMP_OFF;
+  set_pmp_and_sync(pmp_idx, pmp_config);
+
+  return;
+}
+
+//TODO Only handle for the __riscv_64
+void set_pmp_reg(int pmp_idx, uintptr_t* pmp_address, uintptr_t* pmp_config)
+{
+  uintptr_t tmp_pmp_address, tmp_pmp_config;
+  tmp_pmp_address = *pmp_address;
+  tmp_pmp_config = *pmp_config;
+  switch(pmp_idx)
+  {
+    case 0:
+      PMP_SET(0, 0, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 1:
+      PMP_SET(1, 0, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 2:
+      PMP_SET(2, 0, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 3:
+      PMP_SET(3, 0, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 4:
+      PMP_SET(4, 0, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 5:
+      PMP_SET(5, 0, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 6:
+      PMP_SET(6, 0, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 7:
+      PMP_SET(7, 0, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 8:
+      PMP_SET(8, 2, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 9:
+      PMP_SET(9, 2, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 10:
+      PMP_SET(10, 2, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 11:
+      PMP_SET(11, 2, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 12:
+      PMP_SET(12, 2, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 13:
+      PMP_SET(13, 2, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 14:
+      PMP_SET(14, 2, tmp_pmp_address, tmp_pmp_config);
+      break;
+    case 15:
+      PMP_SET(15, 2, tmp_pmp_address, tmp_pmp_config);
+      break;
+    default:
+      break;
+  }
+  *pmp_address = tmp_pmp_address;
+  *pmp_config = tmp_pmp_config;
+}
+
+void set_pmp(int pmp_idx, struct pmp_config_t pmp_cfg_t)
+{
+  uintptr_t pmp_address = 0;
+  uintptr_t old_config = 0;
+  uintptr_t pmp_config = ((pmp_cfg_t.mode & PMP_A) | (pmp_cfg_t.perm & (PMP_R|PMP_W|PMP_X)))
+    << ((uintptr_t)PMPCFG_BIT_NUM * (pmp_idx % PMP_PER_CFG_REG));
+
+  switch(pmp_cfg_t.mode)
+  {
+    case PMP_A_NAPOT:
+      if(pmp_cfg_t.paddr == 0 && pmp_cfg_t.size == -1UL)
+        pmp_address = -1UL;
+      else
+        pmp_address = (pmp_cfg_t.paddr | ((pmp_cfg_t.size>>1)-1)) >> 2;
+      break;
+    case PMP_A_TOR:
+      pmp_address = pmp_cfg_t.paddr;
+      break;
+    case PMP_A_NA4:
+      pmp_address = pmp_cfg_t.paddr;
+    case PMP_OFF:
+      pmp_address = 0;
+      break;
+    default:
+      pmp_address = 0;
+      break;
+  }
+  set_pmp_reg(pmp_idx, &pmp_address, &pmp_config);
+
+  return;
+}
+
+void clear_pmp(int pmp_idx)
+{
+  struct pmp_config_t pmp_cfg_t;
+
+  pmp_cfg_t.mode = PMP_OFF;
+  pmp_cfg_t.perm = PMP_NO_PERM;
+  pmp_cfg_t.paddr = 0;
+  pmp_cfg_t.size = 0;
+  set_pmp(pmp_idx, pmp_cfg_t);
+
+  return;
+}
+
+struct pmp_config_t get_pmp(int pmp_idx)
+{
+  struct pmp_config_t pmp = {0,};
+  uintptr_t pmp_address = 0;
+  uintptr_t pmp_config = 0;
+  unsigned long order = 0;
+  unsigned long size = 0;
+
+  set_pmp_reg(pmp_idx, &pmp_address, &pmp_config);
+
+  pmp_config >>= (uintptr_t)PMPCFG_BIT_NUM * (pmp_idx % PMP_PER_CFG_REG);
+  pmp_config &= PMPCFG_BITS;
+  switch(pmp_config & PMP_A)
+  {
+    case PMP_A_NAPOT:
+      while(pmp_address & 1)
+      {
+        order += 1;
+        pmp_address >>= 1;
+      }
+      order += 3;
+      size = 1 << order;
+      pmp_address <<= (order-1);
+      break;
+    case PMP_A_NA4:
+      size = 4;
+      break;
+    case PMP_A_TOR:
+      break;
+    case PMP_OFF:
+      pmp_address = 0;
+      size = 0;
+      break;
+  }
+
+  pmp.mode = pmp_config & PMP_A;
+  pmp.perm = pmp_config & (PMP_R | PMP_W | PMP_X);
+  pmp.paddr = pmp_address;
+  pmp.size = size;
+
+  return pmp;
+}
diff --git a/opensbi-0.9/lib/sbi/sm/sm.ac b/opensbi-0.9/lib/sbi/sm/sm.ac
new file mode 100644
index 000000000..047997175
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/sm.ac
@@ -0,0 +1,3 @@
+AC_ARG_WITH([target_platform], AS_HELP_STRING([--with-target-platform], [Set a specific platform for the sm to build with]),
+  [AC_SUBST([TARGET_PLATFORM], $with_target_platform, [Set a specific platform for the sm to build with])],
+  [AC_SUBST([TARGET_PLATFORM], pmp, [Set a specific platform for the sm to build with])])
diff --git a/opensbi-0.9/lib/sbi/sm/sm.c b/opensbi-0.9/lib/sbi/sm/sm.c
new file mode 100644
index 000000000..95dcb088e
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/sm.c
@@ -0,0 +1,182 @@
+#include <sm/atomic.h>
+#include <sm/sm.h>
+#include <sm/pmp.h>
+#include <sm/enclave.h>
+#include <sm/math.h>
+
+static int sm_initialized = 0;
+static spinlock_t sm_init_lock = SPINLOCK_INIT;
+
+void sm_init()
+{
+  platform_init();
+}
+
+uintptr_t sm_mm_init(uintptr_t paddr, unsigned long size)
+{
+  uintptr_t retval = 0;
+
+  printm("[Penglai Monitor] %s invoked\r\n",__func__);
+
+  printm("[Penglai Monitor] %s paddr:0x%x, size:0x%x\r\n",__func__, paddr, size);
+  retval = mm_init(paddr, size);
+
+  printm("[Penglai Monitor] %s ret:%d \r\n",__func__, retval);
+  return retval;
+}
+
+uintptr_t sm_mm_extend(uintptr_t paddr, unsigned long size)
+{
+  uintptr_t retval = 0;
+  printm("[Penglai Monitor] %s invoked\r\n",__func__);
+
+  retval = mm_init(paddr, size);
+
+  printm("[Penglai Monitor] %s return:%d\r\n",__func__, retval);
+  return retval;
+}
+
+//TODO: delete this function
+uintptr_t sm_debug_print(uintptr_t* regs, uintptr_t arg0)
+{
+  print_buddy_system();
+  return 0;
+}
+
+uintptr_t sm_alloc_enclave_mem(uintptr_t mm_alloc_arg)
+{
+  struct mm_alloc_arg_t mm_alloc_arg_local;
+  uintptr_t retval = 0;
+
+  printm("[Penglai Monitor] %s invoked\r\n",__func__);
+
+  retval = copy_from_host(&mm_alloc_arg_local,
+      (struct mm_alloc_arg_t*)mm_alloc_arg,
+      sizeof(struct mm_alloc_arg_t));
+  if(retval != 0)
+  {
+    printm("M mode: sm_alloc_enclave_mem: unknown error happended when copy from host\r\n");
+    return ENCLAVE_ERROR;
+  }
+
+  unsigned long resp_size = 0;
+  void* paddr = mm_alloc(mm_alloc_arg_local.req_size, &resp_size);
+  if(paddr == NULL)
+  {
+    printm("M mode: sm_alloc_enclave_mem: no enough memory\r\n");
+    return ENCLAVE_NO_MEMORY;
+  }
+
+  //grant kernel access to this memory
+  if(grant_kernel_access(paddr, resp_size) != 0)
+  {
+    printm("M mode: ERROR: faile to grant kernel access to pa 0x%lx, size 0x%lx\r\n", (unsigned long) paddr, resp_size);
+    mm_free(paddr, resp_size);
+    return ENCLAVE_ERROR;
+  }
+
+  mm_alloc_arg_local.resp_addr = (uintptr_t)paddr;
+  mm_alloc_arg_local.resp_size = resp_size;
+
+  copy_to_host((struct mm_alloc_arg_t*)mm_alloc_arg,
+      &mm_alloc_arg_local,
+      sizeof(struct mm_alloc_arg_t));
+
+  printm("[Penglai Monitor] %s return:%d\r\n",__func__, retval);
+
+  return ENCLAVE_SUCCESS;
+}
+
+uintptr_t sm_create_enclave(uintptr_t enclave_sbi_param)
+{
+  struct enclave_sbi_param_t enclave_sbi_param_local;
+  uintptr_t retval = 0;
+
+  printm("[Penglai Monitor] %s invoked\r\n",__func__);
+
+  retval = copy_from_host(&enclave_sbi_param_local,
+      (struct enclave_sbi_param_t*)enclave_sbi_param,
+      sizeof(struct enclave_sbi_param_t));
+
+  void* paddr = (void*)enclave_sbi_param_local.paddr;
+  unsigned long size = (unsigned long)enclave_sbi_param_local.size;
+  if(retrieve_kernel_access(paddr, size) != 0)
+  {
+    mm_free(paddr, size);
+    return -1UL;
+  }
+
+  //TODO: not finished yet
+  retval = create_enclave(enclave_sbi_param_local);
+
+
+  printm("[Penglai Monitor] %s created return value:%d \r\n",__func__, retval);
+  return retval;
+}
+
+uintptr_t sm_run_enclave(uintptr_t* regs, unsigned long eid)
+{
+  uintptr_t retval;
+  printm("[Penglai Monitor] %s invoked, eid:%d\r\n",__func__, eid);
+
+  retval = run_enclave(regs, (unsigned int)eid);
+
+  printm("[Penglai Monitor] %s return: %d\r\n",__func__, retval);
+
+  return retval;
+}
+
+uintptr_t sm_stop_enclave(uintptr_t* regs, unsigned long eid)
+{
+  uintptr_t retval;
+
+  retval = stop_enclave(regs, (unsigned int)eid);
+
+  return retval;
+}
+
+uintptr_t sm_resume_enclave(uintptr_t* regs, unsigned long eid)
+{
+  uintptr_t retval = 0;
+  uintptr_t resume_func_id = regs[11];
+
+  switch(resume_func_id)
+  {
+    case RESUME_FROM_TIMER_IRQ:
+      //printm("resume from timer irq\r\n");
+      //*HLS()->timecmp = regs[12];
+      csr_read_clear(CSR_MIP, MIP_STIP);
+      csr_read_set(CSR_MIE, MIP_MTIP);
+      retval = resume_enclave(regs, eid);
+      break;
+    case RESUME_FROM_STOP:
+      //printm("resume from stop\r\n");
+      retval = resume_from_stop(regs, eid);
+      break;
+    default:
+      break;
+  }
+
+  return retval;
+}
+
+uintptr_t sm_exit_enclave(uintptr_t* regs, unsigned long retval)
+{
+  uintptr_t ret;
+  printm("[Penglai Monitor] %s invoked\r\n",__func__);
+
+  ret = exit_enclave(regs, retval);
+
+  printm("[Penglai Monitor] %s return: %d\r\n",__func__, ret);
+
+  return ret;
+}
+
+uintptr_t sm_do_timer_irq(uintptr_t *regs, uintptr_t mcause, uintptr_t mepc)
+{
+  uintptr_t ret;
+
+  ret = do_timer_irq(regs, mcause, mepc);
+
+  return ret;
+}
diff --git a/opensbi-0.9/lib/sbi/sm/sm.mk.in b/opensbi-0.9/lib/sbi/sm/sm.mk.in
new file mode 100644
index 000000000..649d7737f
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/sm.mk.in
@@ -0,0 +1,25 @@
+sm_hdrs = \
+  pmp.h \
+  sm.h \
+  enclave_args.h \
+  enclave.h \
+  platform/@TARGET_PLATFORM@/platform.h \
+  thread.h \
+  math.h
+
+sm_c_srcs = \
+  ipi.c \
+  pmp.c \
+  platform/@TARGET_PLATFORM@/platform.c \
+  sm.c \
+  enclave.c \
+  thread.c \
+  math.c
+
+sm_asm_srcs = \
+
+
+sm_test_srcs =
+
+
+sm_install_prog_srcs =
diff --git a/opensbi-0.9/lib/sbi/sm/thread.c b/opensbi-0.9/lib/sbi/sm/thread.c
new file mode 100644
index 000000000..a3c0872de
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/thread.c
@@ -0,0 +1,62 @@
+#include <sm/thread.h>
+//#include <sm/mtrap.h>
+#include <sbi/riscv_encoding.h>
+#include <sbi/riscv_asm.h>
+
+void swap_prev_state(struct thread_state_t* thread, uintptr_t* regs)
+{
+  int i;
+
+  uintptr_t* prev = (uintptr_t*) &thread->prev_state;
+  for(i = 1; i < N_GENERAL_REGISTERS; ++i)
+  {
+    /* swap general registers */
+    uintptr_t tmp = prev[i];
+    prev[i] = regs[i];
+    regs[i] = tmp;
+  }
+
+  return;
+}
+
+void swap_prev_mepc(struct thread_state_t* thread, uintptr_t current_mepc)
+{
+  uintptr_t tmp = thread->prev_mepc;
+  thread->prev_mepc = current_mepc;
+  csr_write(CSR_MEPC, tmp);
+}
+
+void swap_prev_stvec(struct thread_state_t* thread, uintptr_t current_stvec)
+{
+  uintptr_t tmp = thread->prev_stvec;
+  thread->prev_stvec = current_stvec;
+  csr_write(CSR_STVEC, tmp);
+}
+
+void swap_prev_cache_binding(struct thread_state_t* thread, uintptr_t current_cache_binding)
+{
+  uintptr_t tmp = thread->prev_cache_binding;
+  thread->prev_cache_binding = current_cache_binding;
+  //TODO
+}
+
+void swap_prev_mie(struct thread_state_t* thread, uintptr_t current_mie)
+{
+  uintptr_t tmp = thread->prev_mie;
+  thread->prev_mie = current_mie;
+  csr_write(CSR_MIE, tmp);
+}
+
+void swap_prev_mideleg(struct thread_state_t* thread, uintptr_t current_mideleg)
+{
+  uintptr_t tmp = thread->prev_mideleg;
+  thread->prev_mideleg = current_mideleg;
+  csr_write(CSR_MIDELEG, tmp);
+}
+
+void swap_prev_medeleg(struct thread_state_t* thread, uintptr_t current_medeleg)
+{
+  uintptr_t tmp = thread->prev_medeleg;
+  thread->prev_medeleg = current_medeleg;
+  csr_write(CSR_MEDELEG, tmp);
+}
-- 
2.31.1

