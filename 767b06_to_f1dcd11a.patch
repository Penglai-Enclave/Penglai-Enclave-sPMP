diff --git a/opensbi-0.9/include/sm/platform/pmp/enclave_mm.h b/opensbi-0.9/include/sm/platform/pmp/enclave_mm.h
index e652a4094..c563f9fc0 100644
--- a/opensbi-0.9/include/sm/platform/pmp/enclave_mm.h
+++ b/opensbi-0.9/include/sm/platform/pmp/enclave_mm.h
@@ -59,6 +59,8 @@ uintptr_t copy_from_enclave(pte_t *enclave_root_pt, void* dest_pa, void* src_enc
 
 uintptr_t copy_to_enclave(pte_t *enclave_root_pt, void* dest_enclave_va, void* src_pa, size_t size);
 
+int check_enclave_pt(struct enclave_t *enclave);
+
 int grant_kernel_access(void* paddr, unsigned long size);
 
 int grant_enclave_access(struct enclave_t* enclave);
diff --git a/opensbi-0.9/lib/sbi/objects.mk b/opensbi-0.9/lib/sbi/objects.mk
index af2f39149..70fb6b88d 100644
--- a/opensbi-0.9/lib/sbi/objects.mk
+++ b/opensbi-0.9/lib/sbi/objects.mk
@@ -64,6 +64,7 @@ libsbi-objs-y += sm/gm/miracl/mrarth3.o
 libsbi-objs-y += sm/gm/miracl/mrjack.o
 libsbi-objs-y += sm/gm/miracl/mrbits.o
 libsbi-objs-y += sm/gm/miracl/mrmonty.o
+libsbi-objs-y += sm/gm/miracl/mrrand.o
 libsbi-objs-y += sm/gm/miracl/mrsroot.o
 libsbi-objs-y += sm/gm/miracl/mrlucas.o
 libsbi-objs-y += sm/gm/SM2_sv.o
diff --git a/opensbi-0.9/lib/sbi/sm/attest.c b/opensbi-0.9/lib/sbi/sm/attest.c
index 050ca2e68..2d959fcd9 100644
--- a/opensbi-0.9/lib/sbi/sm/attest.c
+++ b/opensbi-0.9/lib/sbi/sm/attest.c
@@ -42,7 +42,7 @@ static int hash_enclave_mem(SM3_STATE *hash_ctx, pte_t* ptes, int level,
                 SM3_process(hash_ctx, (unsigned char*)&curr_va,
                     sizeof(uintptr_t));
                 //update hash with  page attribution
-                SM3_process(hash_ctx, (unsigned char*)pte+7, 1);
+                SM3_process(hash_ctx, (unsigned char*)pte, 1);
                 hash_curr_va = 0;
             }
 
@@ -75,8 +75,18 @@ void hash_enclave(struct enclave_t *enclave, void* hash, uintptr_t nonce_arg)
 
     SM3_init(&hash_ctx);
     
+    // entry point
     SM3_process(&hash_ctx, (unsigned char*)(&(enclave->entry_point)),
         sizeof(unsigned long));
+    // configuration parameters
+    SM3_process(&hash_ctx, (unsigned char*)(&(enclave->untrusted_ptr)),
+        sizeof(unsigned long));
+    SM3_process(&hash_ctx, (unsigned char*)(&(enclave->untrusted_size)),
+        sizeof(unsigned long));
+    SM3_process(&hash_ctx, (unsigned char*)(&(enclave->kbuffer)),
+        sizeof(unsigned long));
+    SM3_process(&hash_ctx, (unsigned char*)(&(enclave->kbuffer_size)),
+        sizeof(unsigned long));
     hash_enclave_mem(
         &hash_ctx,
         (pte_t*)(enclave->thread_context.encl_ptbr << RISCV_PGSHIFT),
diff --git a/opensbi-0.9/lib/sbi/sm/enclave.c b/opensbi-0.9/lib/sbi/sm/enclave.c
index 239b2f07c..1bca95abf 100644
--- a/opensbi-0.9/lib/sbi/sm/enclave.c
+++ b/opensbi-0.9/lib/sbi/sm/enclave.c
@@ -380,20 +380,21 @@ int swap_from_enclave_to_host(uintptr_t* regs, struct enclave_t* enclave)
 uintptr_t create_enclave(struct enclave_sbi_param_t create_args)
 {
 	struct enclave_t* enclave;
+	unsigned int eid;
 	uintptr_t retval = 0;
 
 	enclave = alloc_enclave();
 	if(!enclave)
 	{
 		printm("[Penglai Monitor@%s] enclave allocation is failed \r\n", __func__);
-		return -1UL;
+		sbi_memset((void*)(create_args.paddr), 0, create_args.size);
+		mm_free((void*)(create_args.paddr), create_args.size);
+		return ENCLAVE_ERROR;
 	}
 
-	//TODO: check whether enclave memory is out of bound
-	//TODO: verify enclave page table layout
-
 	spin_lock(&enclave_metadata_lock);
 
+	eid = enclave->eid;
 	enclave->paddr = create_args.paddr;
 	enclave->size = create_args.size;
 	enclave->entry_point = create_args.entry_point;
@@ -417,7 +418,6 @@ uintptr_t create_enclave(struct enclave_sbi_param_t create_args)
 	dump_pt(enclave->root_page_table, 1);
 #endif
 
-	spin_unlock(&enclave_metadata_lock);
 	printm("[Penglai@%s] paddr:0x%lx, size:0x%lx, entry:0x%lx\n"
 			"untrusted ptr:0x%lx host_ptbr:0x%lx, pt:0x%ln\n"
 			"thread_context.encl_ptbr:0x%lx\n cur_satp:0x%lx\n",
@@ -426,17 +426,44 @@ uintptr_t create_enclave(struct enclave_sbi_param_t create_args)
 			enclave->thread_context.encl_ptbr, csr_read(CSR_SATP));
 
 	// Calculate the enclave's measurement
+	hash_enclave(enclave, (void*)(enclave->hash), 0);
+
+	// TODO: verify hash and whitelist check
+
+	// Check page table mapping secure and not out of bound
+	retval = check_enclave_pt(enclave);
+	if(retval != 0)
+	{
+		printm_err("M mode: create_enclave: check enclave page table failed, create failed\r\n");
+		goto error_out;
+	}
+
 	retval = copy_word_to_host((unsigned int*)create_args.eid_ptr, enclave->eid);
 	if(retval != 0)
 	{
 		printm_err("M mode: create_enclave: unknown error happended when copy word to host\r\n");
-		return ENCLAVE_ERROR;
+		goto error_out;
 	}
 
 	printm("[Penglai Monitor@%s] return eid:%d\n",
 			__func__, enclave->eid);
 
+	spin_unlock(&enclave_metadata_lock);
 	return 0;
+
+/*
+ * If create failed for above reasons, secure memory and enclave struct
+ * allocated before will never be used. So we need to free these momery.
+ */
+error_out:
+	sbi_memset((void*)(enclave->paddr), 0, enclave->size);
+	mm_free((void*)(enclave->paddr), enclave->size);
+
+	spin_unlock(&enclave_metadata_lock);
+
+	//free enclave struct
+	free_enclave(eid); //the enclave state will be set INVALID here
+	return ENCLAVE_ERROR;
 }
 
 uintptr_t run_enclave(uintptr_t* regs, unsigned int eid)
@@ -570,6 +597,7 @@ uintptr_t destroy_enclave(uintptr_t* regs, unsigned int eid)
 	if (enclave->state == FRESH) {
 		sbi_memset((void*)(enclave->paddr), 0, enclave->size);
 		mm_free((void*)(enclave->paddr), enclave->size);
+		enclave->state = INVALID;
 
 		spin_unlock(&enclave_metadata_lock);
 
@@ -607,7 +635,7 @@ uintptr_t resume_from_stop(uintptr_t* regs, unsigned int eid)
 
 	if(enclave->state != STOPPED)
 	{
-		printm("[Penglai Monitor@%s]  enclave doesn't belong to current host process\r\n", __func__);
+		printm("[Penglai Monitor@%s] enclave's state is not stopped\r\n", __func__);
 		retval = -1UL;
 		goto resume_from_stop_out;
 	}
@@ -701,7 +729,6 @@ uintptr_t attest_enclave(uintptr_t eid, uintptr_t report_ptr, uintptr_t nonce)
 	sbi_memcpy((void*)(report.sm.sm_pub_key), (void*)SM_PUB_KEY, PUBLIC_KEY_SIZE);
 	sbi_memcpy((void*)(report.sm.signature), (void*)SM_SIGNATURE, SIGNATURE_SIZE);
 
-	hash_enclave(enclave, (void*)(enclave->hash), 0);
 	update_enclave_hash((char *)(report.enclave.hash), (char *)enclave->hash, nonce);
 	sign_enclave((void*)(report.enclave.signature), (void*)(report.enclave.hash), HASH_SIZE);
 	report.enclave.nonce = nonce;
@@ -714,10 +741,8 @@ uintptr_t attest_enclave(uintptr_t eid, uintptr_t report_ptr, uintptr_t nonce)
 
 uintptr_t exit_enclave(uintptr_t* regs, unsigned long retval)
 {
-
-	struct enclave_t *enclave;
-	int eid;
-
+	int eid = get_enclave_id();
+	struct enclave_t *enclave = NULL;
 	if(check_in_enclave_world() < 0)
 	{
 		printm_err("[Penglai Monitor@%s] cpu is not in enclave world now\r\n", __func__);
@@ -725,17 +750,11 @@ uintptr_t exit_enclave(uintptr_t* regs, unsigned long retval)
 	}
 	printm_err("[Penglai Monitor@%s] retval of enclave is %lx\r\n", __func__, retval);
 
-	eid = get_enclave_id();
 	enclave = get_enclave(eid);
-	if(!enclave)
-	{
-		printm("[Penglai Monitor@%s] didn't find eid%d 's corresponding enclave\r\n", __func__, eid);
-		return -1UL;
-	}
 
 	spin_lock(&enclave_metadata_lock);
 
-	if(check_enclave_authentication(enclave) < 0)
+	if(!enclave || check_enclave_authentication(enclave)!=0 || enclave->state != RUNNING)
 	{
 		printm_err("[Penglai Monitor@%s] current enclave's eid is not %d\r\n", __func__, eid);
 		spin_unlock(&enclave_metadata_lock);
@@ -769,6 +788,9 @@ uintptr_t enclave_sys_write(uintptr_t* regs)
 	}
 
 	enclave = get_enclave(eid);
+
+	spin_lock(&enclave_metadata_lock);
+
 	if(!enclave || check_enclave_authentication(enclave)!=0 || enclave->state != RUNNING)
 	{
 		ret = -1UL;
@@ -776,8 +798,6 @@ uintptr_t enclave_sys_write(uintptr_t* regs)
 		goto out;
 	}
 
-	spin_lock(&enclave_metadata_lock);
-
 	uintptr_t ocall_func_id = OCALL_SYS_WRITE;
 	copy_to_host((uintptr_t*)enclave->ocall_func_id, &ocall_func_id, sizeof(uintptr_t));
 
@@ -814,14 +834,16 @@ uintptr_t enclave_derive_seal_key(uintptr_t* regs, uintptr_t salt_va, uintptr_t
 	}
 
 	enclave = get_enclave(eid);
+
+	spin_lock(&enclave_metadata_lock);
+
 	if(!enclave || check_enclave_authentication(enclave)!=0 || enclave->state != RUNNING)
 	{
+		ret = -1UL;
 		printm_err("[Penglai Monitor@%s] check enclave authentication is failed\n", __func__);
-		return -1;
+		goto out;
 	}
 
-	spin_lock(&enclave_metadata_lock);
-
 	enclave_root_pt = (pte_t*)(enclave->thread_context.encl_ptbr << RISCV_PGSHIFT);
 	ret = copy_from_enclave(enclave_root_pt, salt_local, (void *)salt_va, salt_len);
 	if(ret != 0)
@@ -862,6 +884,9 @@ uintptr_t enclave_user_defined_ocall(uintptr_t* regs, uintptr_t ocall_buf_size)
 	}
 
 	enclave = get_enclave(eid);
+
+	spin_lock(&enclave_metadata_lock);
+
 	if(!enclave || check_enclave_authentication(enclave)!=0 || enclave->state != RUNNING)
 	{
 		ret = -1UL;
@@ -869,8 +894,6 @@ uintptr_t enclave_user_defined_ocall(uintptr_t* regs, uintptr_t ocall_buf_size)
 		goto out;
 	}
 
-	spin_lock(&enclave_metadata_lock);
-
 	uintptr_t ocall_func_id = OCALL_USER_DEFINED;
 	copy_to_host((uintptr_t*)enclave->ocall_func_id, &ocall_func_id, sizeof(uintptr_t));
 	copy_to_host((uintptr_t*)enclave->ocall_arg0, &ocall_buf_size, sizeof(uintptr_t));
@@ -905,9 +928,13 @@ uintptr_t do_timer_irq(uintptr_t *regs, uintptr_t mcause, uintptr_t mepc)
 
 	spin_lock(&enclave_metadata_lock);
 
-	if (enclave->state != RUNNING && enclave->state != RUNNABLE)
-	{
-		printm("[Penglai Monitor@%s]  Enclave(%d) is not runnable\r\n", __func__, eid);
+	/*
+	 * An enclave trapping into monitor should not have other states.
+	 * This is guaranteed by concurrency control for life cycle managementã€‚
+	 */
+	if (enclave->state != RUNNING && enclave->state != DESTROYED &&
+		enclave->state != STOPPED) {
+		printm_err("[Penglai Monitor@%s]  Enclave(%d) state is wrong!\r\n", __func__, eid);
 		retval = -1;
 	}
 
diff --git a/opensbi-0.9/lib/sbi/sm/gm/SM2_sv.c b/opensbi-0.9/lib/sbi/sm/gm/SM2_sv.c
index 6111a2e65..2fe405026 100644
--- a/opensbi-0.9/lib/sbi/sm/gm/SM2_sv.c
+++ b/opensbi-0.9/lib/sbi/sm/gm/SM2_sv.c
@@ -36,6 +36,7 @@
 #include <sm/print.h>
 #include <sbi/sbi_string.h>
 #include <sbi/riscv_asm.h>
+#include <sbi/sbi_timer.h>
 
 #define MAX_MESSAGE_SIZE 1024
 
@@ -70,6 +71,10 @@ char g_mem_point[MR_ECP_RESERVE(2)];
 
 static void MIRACL_Init()
 {
+    unsigned long seed;
+
+    seed = sbi_timer_value();
+	printm("Initialize Penglai's random system with seed 0x%lx (sbi_timer_value)\n", seed);
 #ifdef PENGLAI_DEBUG
 	miracl *mip = mirsys(128, 16);
 	printm("MIRACL: pack: %d, nib: %d, big size: %ld, point size: %ld, workspace ptr: %lx\n",
@@ -78,6 +83,7 @@ static void MIRACL_Init()
 #else
 	mirsys(128, 16);
 #endif
+    irand((unsigned int)seed);
 }
 
 /****************************************************************
@@ -280,16 +286,34 @@ int Test_Range(big x)
 	return 0;
 }
 
-/* the private key, a big number lies in[1,n-2]
- * FIX ME: generate a random private key, now it's a fixed plaintext.
+/* 
+ * the private key, a big number lies in[1,n-2]
  */
 static void SM2_make_prikey(unsigned char prikey[])
 {
+#ifdef PENGLAI_RANDOM_PRIKEY
+	big x, one, decr_n2;
+	char mem[MR_BIG_RESERVE(3)];
+
+	sbi_memset(mem, 0, MR_BIG_RESERVE(3));
+	x 		= mirvar_mem(mem, 0);
+	one 	= mirvar_mem(mem, 1);
+	decr_n2 = mirvar_mem(mem, 2);
+
+	convert(1, one);
+	decr(n, 2, decr_n2);
+	do{
+		bigrand(n, x); // generate a big random number 0<=x<n
+	}while((mr_compare(x, one) < 0) | (mr_compare(x, decr_n2) > 0));
+
+	big_to_bytes(SM2_NUMWORD, x, (char *)prikey, TRUE);
+#else
 	unsigned char dA[32] = {
 		0x39, 0x45, 0x20, 0x8f, 0x7b, 0x21, 0x44, 0xb1, 0x3f, 0x36, 0xe3, 0x8a, 0xc6, 0xd3, 0x9f, 0x95,
 		0x88, 0x93, 0x93, 0x69, 0x28, 0x60, 0xb5, 0x1a, 0x42, 0xfb, 0x81, 0xef, 0x4d, 0xf7, 0xc5, 0xb8};
 
 	sbi_memcpy(prikey, dA, 32);
+#endif
 }
 
 /****************************************************************
@@ -360,16 +384,26 @@ int SM2_KeyGeneration(unsigned char PriKey[], unsigned char Px[], unsigned char
 	return 0;
 }
 
-/* random, a random number K lies in [1,n-1]
- * FIX ME: generate a random number, now function gen_random just generate a fixed number.
+/* 
+ * random, a random number K lies in [1,n-1]
  */
 static void SM2_gen_random(unsigned char rand[])
 {
-	unsigned char temp[32] = {
-		0x59, 0x27, 0x6E, 0x27, 0xD5, 0x06, 0x86, 0x1A, 0x16, 0x68, 0x0F, 0x3A, 0xD9, 0xC0, 0x2D, 0xCC,
-		0xEF, 0x3C, 0xC1, 0xFA, 0x3C, 0xDB, 0xE4, 0xCE, 0x6D, 0x54, 0xB8, 0x0D, 0xEA, 0xC1, 0xBC, 0x21};
-	
-	sbi_memcpy(rand, temp, 32);
+	big x, one, decr_n1;
+	char mem[MR_BIG_RESERVE(3)];
+
+	sbi_memset(mem, 0, MR_BIG_RESERVE(3));
+	x 		= mirvar_mem(mem, 0);
+	one 	= mirvar_mem(mem, 1);
+	decr_n1 = mirvar_mem(mem, 2);
+
+	convert(1, one);
+	decr(n, 1, decr_n1);
+	do{
+		bigrand(n, x); // generate a big random number 0<=x<n
+	}while((mr_compare(x, one) < 0) | (mr_compare(x, decr_n1) > 0));
+
+	big_to_bytes(SM2_NUMWORD, x, (char *)rand, TRUE);
 }
 
 /****************************************************************
diff --git a/opensbi-0.9/lib/sbi/sm/gm/miracl/mrrand.c b/opensbi-0.9/lib/sbi/sm/gm/miracl/mrrand.c
new file mode 100644
index 000000000..31ca79697
--- /dev/null
+++ b/opensbi-0.9/lib/sbi/sm/gm/miracl/mrrand.c
@@ -0,0 +1,110 @@
+
+/***************************************************************************
+                                                                           *
+Copyright 2013 CertiVox UK Ltd.                                           *
+                                                                           *
+This file is part of CertiVox MIRACL Crypto SDK.                           *
+                                                                           *
+The CertiVox MIRACL Crypto SDK provides developers with an                 *
+extensive and efficient set of cryptographic functions.                    *
+For further information about its features and functionalities please      *
+refer to http://www.certivox.com                                           *
+                                                                           *
+* The CertiVox MIRACL Crypto SDK is free software: you can                 *
+  redistribute it and/or modify it under the terms of the                  *
+  GNU Affero General Public License as published by the                    *
+  Free Software Foundation, either version 3 of the License,               *
+  or (at your option) any later version.                                   *
+                                                                           *
+* The CertiVox MIRACL Crypto SDK is distributed in the hope                *
+  that it will be useful, but WITHOUT ANY WARRANTY; without even the       *
+  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. *
+  See the GNU Affero General Public License for more details.              *
+                                                                           *
+* You should have received a copy of the GNU Affero General Public         *
+  License along with CertiVox MIRACL Crypto SDK.                           *
+  If not, see <http://www.gnu.org/licenses/>.                              *
+                                                                           *
+You can be released from the requirements of the license by purchasing     *
+a commercial license. Buying such a license is mandatory as soon as you    *
+develop commercial activities involving the CertiVox MIRACL Crypto SDK     *
+without disclosing the source code of your own applications, or shipping   *
+the CertiVox MIRACL Crypto SDK with a closed source product.               *
+                                                                           *
+***************************************************************************/
+/*
+ *   MIRACL random number routines
+ *   mrrand.c
+ */
+
+#include "sm/gm/miracl/miracl.h"
+
+#ifdef MR_FP
+#include <math.h>
+#endif
+
+#ifndef MR_NO_RAND
+
+void bigrand(_MIPD_ big w,big x)
+{  /*  generate a big random number 0<=x<w  */
+    int m;
+    mr_small r;
+#ifdef MR_FP
+    mr_small dres;
+#endif
+#ifdef MR_OS_THREADS
+    miracl *mr_mip=get_mip();
+#endif
+    if (mr_mip->ERNUM) return;
+
+    MR_IN(20)
+
+ /*   decr(_MIPP_ w,2,w);  */
+    m=0;
+    zero(mr_mip->w0);
+
+    do
+    { /* create big rand piece by piece */
+        m++;
+        mr_mip->w0->len=m;
+        r=brand(_MIPPO_ );
+        if (mr_mip->base==0) mr_mip->w0->w[m-1]=r;
+        else                 mr_mip->w0->w[m-1]=MR_REMAIN(r,mr_mip->base);
+    } while (mr_compare(mr_mip->w0,w)<0);
+    mr_lzero(mr_mip->w0);
+    divide(_MIPP_ mr_mip->w0,w,w);
+
+    copy(mr_mip->w0,x);
+ /*   incr(_MIPP_ x,2,x);
+    if (w!=x) incr(_MIPP_ w,2,w); */
+    MR_OUT
+}
+
+void bigdig(_MIPD_ int n,int b,big x)
+{ /* generate random number n digits long *
+   * to "printable" base b                */
+#ifdef MR_OS_THREADS
+    miracl *mr_mip=get_mip();
+#endif
+    if (mr_mip->ERNUM) return;
+
+    MR_IN(19)
+
+    if (b<2 || b>256)
+    {
+        mr_berror(_MIPP_ MR_ERR_BASE_TOO_BIG);
+        MR_OUT
+        return;
+    }
+
+    do
+    { /* repeat if x too small */
+        expint(_MIPP_ b,n,mr_mip->w1);
+        bigrand(_MIPP_ mr_mip->w1,x);
+        subdiv(_MIPP_ mr_mip->w1,b,mr_mip->w1);
+    } while (!mr_mip->ERNUM && mr_compare(x,mr_mip->w1)<0);
+
+    MR_OUT
+}
+
+#endif
diff --git a/opensbi-0.9/lib/sbi/sm/platform/pmp/enclave_mm.c b/opensbi-0.9/lib/sbi/sm/platform/pmp/enclave_mm.c
index 2ad53149a..5fbe1b91b 100644
--- a/opensbi-0.9/lib/sbi/sm/platform/pmp/enclave_mm.c
+++ b/opensbi-0.9/lib/sbi/sm/platform/pmp/enclave_mm.c
@@ -139,6 +139,140 @@ static pte_t* walk_enclave_pt(pte_t *enclave_root_pt, uintptr_t vaddr)
 	return &pgdir[get_pt_index(vaddr , level - 1)];
 }
 
+static int iterate_over_enclave_pages(pte_t* ptes, int level, uintptr_t va,
+					int (*check)(uintptr_t, uintptr_t, int))
+{
+	uintptr_t pte_per_page = RISCV_PGSIZE/sizeof(pte_t);
+	pte_t *pte;
+	uintptr_t i = 0;
+
+	//should never happen
+	if(level <= 0)
+		return 1;
+
+	for(pte = ptes, i = 0; i < pte_per_page; pte += 1, i += 1)
+	{
+		if(!(*pte & PTE_V))
+		{
+			continue;
+		}
+
+		uintptr_t curr_va = 0;
+		if(level == ((VA_BITS - RISCV_PGSHIFT) / RISCV_PGLEVEL_BITS))
+			curr_va = (uintptr_t)(-1UL << VA_BITS) +
+				(i << (VA_BITS - RISCV_PGLEVEL_BITS));
+		else
+			curr_va = va +
+				(i << ((level-1) * RISCV_PGLEVEL_BITS + RISCV_PGSHIFT));
+		uintptr_t pa = (*pte >> PTE_PPN_SHIFT) << RISCV_PGSHIFT;
+
+		//found leaf pte
+		if ((*pte & PTE_R) || (*pte & PTE_X)) {
+			//4K page
+			if (level == 1) {
+				if (check(curr_va, pa, 1 << RISCV_PGSHIFT) != 0)
+					return -1;
+			}
+			//2M page
+			else if (level == 2) {
+				if (check(curr_va, pa, 1 << (RISCV_PGSHIFT +
+						RISCV_PGLEVEL_BITS)) != 0)
+					return -1;
+			}
+		} else {
+			if (iterate_over_enclave_pages((pte_t *)pa, level - 1,
+							   curr_va, check) != 0)
+				return -1;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * \brief This function check the enclave page table set up by
+ * kernel driver. Check two things:
+ *  1. Enclave's trusted memory pages are mapped to its own secure
+ *	 memory, falling within a pmp region and not out of bound to
+ *	 other enclave's memory.
+ *  2. Untrusted memory and kbuffer are mapped to normal kernel
+ *	 memory that doesn't belong to any existing pmp regions.
+ * 
+ * Note: 
+ *   Need invocate hash_verify() and whitelist_check() first to
+ * guarantee the validness of enclave vaddr and the authenticity
+ * of untrusted memory and kbuffer which were passed by kernel
+ * driver. 
+ *   When SM hash an enclave, it will take into account configuration
+ * parameters such as untrusted memory and kbuffer (each has two
+ * part: a start vaddr in enclave address space and a size).
+ */
+int check_enclave_pt(struct enclave_t *enclave)
+{
+	uintptr_t retval = 0;
+	// umem and kbuffer pointer specified by user may only specify
+	// low-order VA_BITS bits, but without high-order 1s.
+	unsigned long enclave_untrusted_vaddr =
+		(uintptr_t)(-1UL << VA_BITS) | enclave->untrusted_ptr;
+	unsigned long enclave_kbuffer_vaddr =
+		(uintptr_t)(-1UL << VA_BITS) | enclave->kbuffer;
+	unsigned long page_mask = (1 << RISCV_PGSHIFT) - 1;
+
+	// check umem and kbuffer pointer and size, align by page.
+	if ((enclave_untrusted_vaddr & page_mask) != 0 ||
+		(enclave->untrusted_size & page_mask) != 0 ||
+		(enclave_kbuffer_vaddr & page_mask) != 0 ||
+		(enclave->kbuffer_size & page_mask) != 0) {
+		printm_err(
+			"[Penglai Monitor@%s] Error: Enclave untrusted mem or "
+			"kbuffer are not aligned by page.\r\n",
+			__func__);
+		return -1;
+	}
+
+	/* For Debug */
+	printm("Enclave's own secure momery: pa: 0x%lx, size: 0x%lx\r\n",
+		enclave->paddr, enclave->size);
+
+	// check trusted mem, untrusted mem and kbuffer
+	int check_page(uintptr_t va, uintptr_t pa, int page_size)
+	{
+		if (region_contain(enclave_untrusted_vaddr,
+				   enclave->untrusted_size, va, page_size) ||
+			region_contain(enclave_kbuffer_vaddr, enclave->kbuffer_size, va,
+				   page_size)) {
+			if (!data_is_nonsecure(pa, page_size)) {
+				printm_err("Error: untrusted memory pages fall within "
+					"secure region! va: 0x:%lx, pa: 0x%lx, size: 0x%x\r\n",
+					va, pa, page_size);
+				return -1;
+			}
+		} else {
+			if (!region_contain(enclave->paddr, enclave->size, pa,
+						page_size)) {
+				printm_err(
+					"Error: trusted memory pages fall out of enclave's "
+					"own secure momery! va: 0x%lx, pa: 0x%lx, size: 0x%x\r\n",
+					va, pa, page_size);
+				return -1;
+			}
+		}
+
+		return 0;
+	}
+	retval = iterate_over_enclave_pages(
+		(pte_t*)(enclave->thread_context.encl_ptbr << RISCV_PGSHIFT),
+		(VA_BITS - RISCV_PGSHIFT) / RISCV_PGLEVEL_BITS, 0, check_page
+	);
+	if(retval != 0){
+		printm_err("[Penglai Monitor@%s] Error: Enclave page table check failed, retval %d.\n",
+			__func__, (int)retval);
+		return -1;
+	}
+
+	return 0;
+}
+
 uintptr_t get_enclave_paddr_from_va(pte_t *enclave_root_pt, uintptr_t vaddr)
 {
 	pte_t *pte = walk_enclave_pt(enclave_root_pt, vaddr);
@@ -294,6 +428,15 @@ int grant_kernel_access(void* req_paddr, unsigned long size)
 	struct pmp_config_t pmp_config;
 	uintptr_t paddr = (uintptr_t)req_paddr;
 
+	pmp_config = get_pmp(pmp_idx);
+	if((pmp_config.mode != PMP_OFF))
+	{
+		printm_err(
+			"grant_kernel_access: can't grant kernel access to a new memory"
+			"region if kernel has already access to another one\r\n");
+		return -1;
+	}
+
 	if(check_mem_size(paddr, size) != 0){
 		printm("[Penglai Monitor@%s] check_mem_size failed\n", __func__);
 		return -1;
@@ -363,12 +506,19 @@ int grant_enclave_access(struct enclave_t* enclave)
 
 	pmp_idx = REGION_TO_PMP(region_idx);
 #if 0
-	pmp_config.paddr = mm_regions[region_idx].paddr;
-	pmp_config.size = mm_regions[region_idx].size;
-#else
-	//this enclave memory region could be less than the mm_region size
 	pmp_config.paddr = enclave->paddr;
 	pmp_config.size = enclave->size;
+#else
+	/* Even if we set this PMP region only contain the enclave's secure memory,
+	 * the enclave still have access to the secure memory of other enclaves,
+	 * which using the same pmp to protect their memory from OS access before.
+	 * That's because the last pmp makes all momery accessible.
+	 * And we rule out this possibility by checking the enclave page table.
+	 *
+	 * So we just make this PMP region readable, writable and executable.
+	 */
+	pmp_config.paddr = mm_regions[region_idx].paddr;
+	pmp_config.size = mm_regions[region_idx].size;
 #endif
 	pmp_config.perm = PMP_R | PMP_W | PMP_X;
 	pmp_config.mode = PMP_A_NAPOT;
@@ -392,7 +542,7 @@ int retrieve_enclave_access(struct enclave_t *enclave)
 {
 	int region_idx = 0;
 	int pmp_idx = 0;
-	//struct pmp_config_t pmp_config;
+	struct pmp_config_t pmp_config;
 
 	//set pmp permission, ensure that enclave's paddr and size is pmp legal
 	//TODO: support multiple memory regions
@@ -425,8 +575,14 @@ int retrieve_enclave_access(struct enclave_t *enclave)
 
 	pmp_idx = REGION_TO_PMP(region_idx);
 
-	// we can simply clear the PMP to retrieve the permission
-	clear_pmp(pmp_idx);
+	// set PMP to protect the entire PMP region
+	pmp_config.paddr = mm_regions[region_idx].paddr;
+	pmp_config.size = mm_regions[region_idx].size;
+	pmp_config.perm = PMP_NO_PERM;
+	pmp_config.mode = PMP_A_NAPOT;
+
+	/* Note: here we only set the PMP regions in local Hart*/
+	set_pmp(pmp_idx, pmp_config);
 
 	return 0;
 }
diff --git a/opensbi-0.9/lib/sbi/sm/pmp.c b/opensbi-0.9/lib/sbi/sm/pmp.c
index 550a75845..7408b5ea1 100644
--- a/opensbi-0.9/lib/sbi/sm/pmp.c
+++ b/opensbi-0.9/lib/sbi/sm/pmp.c
@@ -164,6 +164,32 @@ void get_pmp_reg(int pmp_idx, uintptr_t* pmp_address, uintptr_t* pmp_config)
 	*pmp_config = tmp_pmp_config;
 }
 
+/*
+ * Check the validness of the paddr and size
+ * */
+static int check_pmp_region_protectable(uintptr_t paddr, unsigned long size)
+{
+	if((size == 0) || (size & (size - 1)))
+	{
+		printm_err("pmp size should be 2^power!\r\n");
+		return -1;
+	}
+
+	if(size < RISCV_PGSIZE)
+	{
+		printm_err("pmp size should be no less than one page!\r\n");
+		return -1;
+	}
+
+	if(paddr & (size - 1))
+	{
+		printm_err("pmp size should be %ld aligned!\r\n", size);
+		return -1;
+	}
+
+	return 0;
+}
+
 /**
  * \brief set current hart's pmp
  *
@@ -183,8 +209,14 @@ void set_pmp(int pmp_idx, struct pmp_config_t pmp_cfg_t)
 		case PMP_A_NAPOT:
 			if(pmp_cfg_t.paddr == 0 && pmp_cfg_t.size == -1UL)
 				pmp_address = -1UL;
-			else
+			else {
+				if(check_pmp_region_protectable(pmp_cfg_t.paddr, pmp_cfg_t.size) != 0){
+					printm_err(
+						"Warning: PMP region with paddr: 0x%lx and size: 0x%lx, can't be protected by pmp registers in NAPOT mode\n",
+						pmp_cfg_t.paddr, pmp_cfg_t.size);
+				}
 				pmp_address = (pmp_cfg_t.paddr | ((pmp_cfg_t.size>>1)-1)) >> 2;
+			}
 			break;
 		case PMP_A_TOR:
 			pmp_address = pmp_cfg_t.paddr;
diff --git a/penglai-enclave-driver/penglai-enclave-ioctl.c b/penglai-enclave-driver/penglai-enclave-ioctl.c
index b3ff50fb5..da1716d3d 100644
--- a/penglai-enclave-driver/penglai-enclave-ioctl.c
+++ b/penglai-enclave-driver/penglai-enclave-ioctl.c
@@ -36,11 +36,11 @@ int create_sbi_param(enclave_t* enclave, struct penglai_enclave_sbi_param * encl
 	enclave_sbi_param -> paddr = paddr;
 	enclave_sbi_param -> size = size;
 	enclave_sbi_param -> entry_point = entry_point;
-	enclave_sbi_param -> untrusted_ptr = untrusted_ptr ;
+	enclave_sbi_param -> untrusted_ptr = untrusted_ptr;
 	enclave_sbi_param -> untrusted_size = untrusted_size;
 	enclave_sbi_param -> free_mem = free_mem;
 	//enclave share mem with kernel
-	enclave_sbi_param->kbuffer = __pa(enclave->kbuffer);
+	enclave_sbi_param->kbuffer = ENCLAVE_DEFAULT_KBUFFER;
 	enclave_sbi_param->kbuffer_size = enclave->kbuffer_size;
 	return 0;
 }
@@ -160,7 +160,7 @@ int penglai_enclave_create(struct file * filep, unsigned long args)
 
 	create_sbi_param(enclave, &enclave_sbi_param,
 			(unsigned long)(enclave->enclave_mem->paddr),
-			enclave->enclave_mem->size, elf_entry, __pa(untrusted_mem_ptr),
+			enclave->enclave_mem->size, elf_entry, DEFAULT_UNTRUSTED_PTR,
 			untrusted_mem_size, __pa(free_mem));
 
 	printk("[Penglai Driver@%s] enclave_mem->paddr:0x%lx, size:0x%lx\n",
diff --git a/sdk b/sdk
index 1ce4a2e63..9c6b7165f 160000
--- a/sdk
+++ b/sdk
@@ -1 +1 @@
-Subproject commit 1ce4a2e63da400a29ea5e05fe8e6569b55bc63ce
+Subproject commit 9c6b7165f630ca3ff90dd4282c458451b40b7d23
